/*--------------------------------------
 * bc.stat - bc.stat.c
 * Created on 24/11/09 by Benjamin Levy
 *--------------------------------------*/


#include "ext.h"				// standard Max include, always required
#include "ext_obex.h"			// required for new style Max object
#include "ext_time.h"
#include "ext_itm.h"


typedef struct _statelem
	{
		bool	enable;
		long	pitch;
		double	nbOcc;
		double	nbtot;
		double	ampacc;
		double	proba;
		void*	clock;
		void*	object;
	} bc_statelem;


////////////////////////// object struct
typedef struct _bc_yinstats 
	{
		t_object		ob;				// the object itself (must be first)
		long			nbstats;		// number of stat agent
		bc_statelem*	stats;			// stat agent vector
		double			minproba;		// minimal probabilty
		long			window;			// window for stats (ms)
		double			lastpitch;		// last pitch
		double			lastamp;		// last amplitude
		long			laststat;		// last stat enable
		void*			out_pitch;		// outlet 0
		void*			out_amp;		// outlet 1
		void*			out_proba;		// outlet 2
	} t_bc_yinstats;

////////////////
// prototypes //
////////////////

// Standard Max5 methodes
void *bc_yinstats_new(t_symbol *s, long argc, t_atom *argv);
void bc_yinstats_free(t_bc_yinstats *x);
void bc_yinstats_assist(t_bc_yinstats *x, void *b, long m, long a, char *s);

// Input/ouput routines
void bc_yinstats_amp(t_bc_yinstats *x, double ampin);
void bc_yinstats_pitch(t_bc_yinstats *x, long pitchin);
void bc_yinstats_out(bc_statelem *stat);
void bc_yinstats_stop(t_bc_yinstats *x);

// Internal routines
bool bc_yinstats_addocc(t_bc_yinstats *x, long pitchin, double ampin);
long bc_yinstats_addstat(t_bc_yinstats *x, long pitchin, double ampin);
void bc_yinstats_reset(t_bc_yinstats *x, bc_statelem *stat);

// Global class pointer variable
void *bc_yinstats_class;


int main(void)
{	
	t_class *c;
	
	c = class_new("bc.yinstats", (method)bc_yinstats_new, (method)bc_yinstats_free, (long)sizeof(t_bc_yinstats), 0L, A_GIMME, 0);
	
	// assistance
    class_addmethod(c, (method)bc_yinstats_assist,"assist",A_CANT, 0); 
	
	// input methods
	class_addmethod(c, (method)bc_yinstats_pitch, "int", A_LONG, 0);
	class_addmethod(c, (method)bc_yinstats_amp, "ft1", A_FLOAT, 0);
	class_addmethod(c, (method)bc_yinstats_stop, "stop", 0);
		
	CLASS_ATTR_LONG(c, "window", 0, t_bc_yinstats, window);
	CLASS_ATTR_LABEL(c, "window", 0, "Window (ms)");
	CLASS_ATTR_SAVE(c, "window", 0);
	CLASS_ATTR_MIN(c, "window", 0, 0);
	
	CLASS_ATTR_DOUBLE(c, "minproba", 0, t_bc_yinstats, minproba);
	CLASS_ATTR_LABEL(c, "minproba", 0, "Probability Threshold");
	CLASS_ATTR_SAVE(c, "minproba", 0);
	CLASS_ATTR_FILTER_CLIP(c, "minproba", 0., 1.);
	
	class_register(CLASS_BOX, c); /* CLASS_NOBOX */
	bc_yinstats_class = c;
	
	return 0;
}

// Object instantiation
void *bc_yinstats_new(t_symbol *s, long argc, t_atom *argv)
{
	t_bc_yinstats *x = NULL;
	
	// object instantiation, NEW STYLE
	if (x = (t_bc_yinstats *)object_alloc(bc_yinstats_class))
	{
		// inlets
		floatin(x, 1); // amplitude
		
		// outlets
		x->out_proba = floatout(x);
		x->out_amp = floatout(x);
		x->out_pitch = intout(x);
		
		x->nbstats = 100;
		x->minproba = 0.;
		
		// process arguments
		switch (argc)
		{
			/*
			case 3:
				if ((argv + 2)->a_type == A_FLOAT);
					x->minproba = atom_getfloat(argv + 2);
			case 2:
				if ((argv + 1)->a_type == A_LONG);
					x->window = atom_getlong(argv + 1);
			 */
			case 1:
				if (argv->a_type == A_LONG)
					x->nbstats = atom_getlong(argv);
				break;
			default:
				object_error((t_object *)x, "Number of stat agents needed");
		}
		
		// process attributes
		// override arguments if needed
		attr_args_process(x, argc, argv);
		
		x->stats = (bc_statelem*)sysmem_newptr(x->nbstats * sizeof(bc_statelem));
		long i;
		for (i = 0; i< x->nbstats; i++)
			bc_yinstats_reset(x, x->stats + i);		
		x->laststat = 0;
	}
	return (x);
}

// Object destruction
void bc_yinstats_free(t_bc_yinstats *x)
{
	long i;
	for (i = 0; i< x->nbstats; i++)
	{
		freeobject(x->stats[i].clock);
	}
	sysmem_freeptr(x->stats);
}

// Inlet/Outlet contextual information when patching in Max5
void bc_yinstats_assist(t_bc_yinstats *x, void *b, long io, long index, char *s)
{
	switch (io)
	{
		case 1: // inlets
			switch (index)
		{
			case 0: // leftmost
				sprintf(s, "pitch");
				break;
			case 1:
				sprintf(s, "amplitude");
				break;
		}
			break;
		case 2: // outlets
			switch (index)
		{
			case 0: // leftmost
				sprintf(s, "coocked pitch");
				break;
			case 1: 
				sprintf(s, "average amplitude");
				break;
			case 2:
				sprintf(s,"probability");
				break;
		}
	}
}

void bc_yinstats_amp(t_bc_yinstats *x, double ampin)
{
	x->lastamp = ampin;
}

void bc_yinstats_pitch(t_bc_yinstats *x, long pitchin)
{
	x->lastpitch = pitchin;
	bc_yinstats_addocc(x, pitchin, x->lastamp);
	bc_yinstats_addstat(x, pitchin, x->lastamp);
}

bool bc_yinstats_addocc(t_bc_yinstats *x, long pitchin, double ampin)
{
	long i;
	bool found = FALSE;
	for (i = 0; i<=(x->laststat); i++)
	{
		if (x->stats[i].enable)
		{
			x->stats[i].nbtot++;
			if (x->stats[i].pitch == pitchin)
			{
				found = TRUE;
				x->stats[i].nbOcc++;
				x->stats[i].ampacc += ampin;
			}
		}
	}
	return found;	
}

long bc_yinstats_addstat(t_bc_yinstats *x, long pitchin, double ampin)
{
	long i = 0;
	while (x->stats[i].enable && i<x->nbstats)
		i++;
	if (i == x->nbstats)
	{
		i = 0;
		object_error((t_object *)x, "too many events");
	}
	x->stats[i].enable = TRUE;
	x->stats[i].pitch = pitchin;
	x->stats[i].ampacc = ampin;
	x->stats[i].nbOcc = 1;
	x->stats[i].nbtot = 1;
	clock_delay(x->stats[i].clock, x->window);
	if (i > (x->laststat))
		x->laststat = i;
	return i;
}

void bc_yinstats_reset(t_bc_yinstats *x, bc_statelem *stat) 
{
	stat->enable = FALSE;
	stat->pitch = 0;
	stat->ampacc = 0.;
	stat->nbOcc = 0;
	stat->nbtot = 0;
	stat->proba = 0.;
	stat->object = x;
	stat->clock = clock_new(stat , (method)bc_yinstats_out);
}

void bc_yinstats_out(bc_statelem *stat)
{
	t_bc_yinstats * x = stat->object;
	stat->proba = stat->nbOcc / stat->nbtot;
	if (stat->proba >= x->minproba)
	{
		outlet_float(x->out_proba, stat->proba);
		outlet_float(x->out_amp, stat->ampacc / stat->nbOcc);
		outlet_int(x->out_pitch, stat->pitch);
	}
	stat->enable = FALSE;
}

void bc_yinstats_stop(t_bc_yinstats *x)
{
	long i;
	for (i = 0; i< x->laststat; i++)
	{
		x->stats[i].enable = FALSE;
		clock_unset(x->stats[i].clock);
	}
	x->laststat = 0;
}
