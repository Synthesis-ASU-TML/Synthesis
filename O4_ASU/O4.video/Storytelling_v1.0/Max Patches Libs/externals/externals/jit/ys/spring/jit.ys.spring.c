////	jit.ys.spring.c//						05.26.03	by Yoichiro Serita#include "jit.common.h"#include "forcestep.h"typedef struct _jit_ys_spring {	t_object				ob;		float len;	float k;	float d;	float gravity_x;	float gravity_y;	float dragCoeff;	float dt;		char forceMask;		float floor;		Particle particle[100];	Spring spring[99];	PSinfo psinfo;		Matrix matrix;		//float param[6];		// parameter	//long paramcount;	} t_jit_ys_spring;void *_jit_ys_spring_class;t_jit_ys_spring *jit_ys_spring_new(void);void jit_ys_spring_free(t_jit_ys_spring *x);t_jit_err jit_ys_spring_matrix_calc(t_jit_ys_spring *x, void *inputs, void *outputs);t_jit_err jit_ys_spring_calculate_ndim(t_jit_ys_spring *x, long dimcount, long *dim, long planecount, 	t_jit_matrix_info *in_minfo, char *bip, t_jit_matrix_info *out_minfo, char *bop);t_jit_err jit_ys_spring_init(void);void setParameters(t_jit_ys_spring *x){	int i;	for(i=0; i<x->psinfo.snum; i++){		x->psinfo.s[i].len = x->len;		x->psinfo.s[i].k = x->k;		x->psinfo.s[i].d = x->d;				x->psinfo.s[i].p1 = i;		x->psinfo.s[i].p2 = i+1;	}	setVec(&x->psinfo.gravity, x->gravity_x, x->gravity_y);	x->psinfo.dragCoeff = x->dragCoeff;	x->psinfo.dt = x->dt;		x->psinfo.forceMask = x->forceMask;}void copyParticles(char *bip, long width, Particle p[]){	int i;	float *fp = (float *)bip;			for(i=0; i<width; i++, fp+=10){		setVec(&p[i].pos, fp[0], fp[1]);		setVec(&p[i].vel, fp[2], fp[3]);		setVec(&p[i].acl, fp[4], fp[5]);		setVec(&p[i].force, fp[6], fp[7]);		p[i].mass = fp[8];		p[i].locked = (fp[9] == 0.0f) ? 0 : 1;	}}void outputParticles(char *bop, long width, Particle p[]){	int i;	float *fp = (float *)bop;			for(i=0; i<width; i++, fp+=10){		fp[0] = p[i].pos.x;		fp[1] = p[i].pos.y;		fp[2] = p[i].vel.x;		fp[3] = p[i].vel.y;		fp[4] = p[i].acl.x;		fp[5] = p[i].acl.y;		fp[6] = p[i].force.x;		fp[7] = p[i].force.y;		fp[8] = p[i].mass;		fp[9] = p[i].locked;	}}void Evaluate(char *bip, char *bop, long width, t_jit_ys_spring *x){	setParameters(x);		x->psinfo.pnum = width;	x->psinfo.snum = width - 1;	copyParticles(bip, width, x->psinfo.p);			//x->psinfo.forceMask = 0x1 | 0x2 | 0x4;	calcForce(&x->psinfo);		forceStep(x->psinfo.p, x->psinfo.pnum, x->psinfo.dt, x->floor, &x->matrix, x->forceMask);				outputParticles(bop, width, x->psinfo.p);	}/*void Evaluate(char *bip, char *bop, long dimstride, long width, long height, float param[]){	long i, j;	long val;               	// apply equation    	for(j=0; j<height; j++){    		uchar *ip = bip + j*dimstride;	// dimstride[1] == width (bytes)		uchar  *op = bop  + j*dimstride;			for( i=0; i<width; i++){						int a1 = (i != width-1) ? ip[(i-1)*2]  : 0;			int a2 = (i != 0) ? ip[(i+1)*2]  : 0;			int a3 = (j != height-1) ? ip[i*2-dimstride]  : 0;			int a4 = (j != 0) ? ip[i*2+dimstride] : 0;														val =  param[0]*ip[i*2] + param[1]*ip[i*2+1] + param[2]*a1 +					param[3]*a2 + param[4]*a3 + param[5]*a4;				    		if(val < 0) val = 0;	    		else if(val > 255) val = 255;	    	    		op[i*2] = val;			op[i*2+1] = ip[i*2];		}    	}}*/t_jit_err jit_ys_spring_init(void) {	long attrflags=0;	t_jit_object *attr;	t_jit_object *mop, *o;		_jit_ys_spring_class = jit_class_new("jit_ys_spring",(method)jit_ys_spring_new,(method)jit_ys_spring_free,		sizeof(t_jit_ys_spring),A_CANT,0L); //A_CANT = untyped	// add mop	mop = jit_object_new(_jit_sym_jit_mop,2,1);	// 1 matrix input / 1 matrix output		// need this for getting correct matrix_info from 2nd input matrix....  (see jit.concat.c...)	jit_mop_input_nolink(mop,2);	o= jit_object_method(mop,_jit_sym_getinput,2);	jit_object_method(o,_jit_sym_ioproc,jit_mop_ioproc_copy_adapt); 			jit_class_addadornment(_jit_ys_spring_class,mop);		// add methods	jit_class_addmethod(_jit_ys_spring_class, (method)jit_ys_spring_matrix_calc, "matrix_calc", A_CANT, 0L);	// add attributes (long array)	attrflags = JIT_ATTR_GET_DEFER_LOW | JIT_ATTR_SET_USURP_LOW;	attr = jit_object_new(_jit_sym_jit_attr_offset,"len",_jit_sym_float32,attrflags,		(method)0L,(method)0L,calcoffset(t_jit_ys_spring,len));	jit_class_addattr(_jit_ys_spring_class,attr);		attr = jit_object_new(_jit_sym_jit_attr_offset,"k",_jit_sym_float32,attrflags,		(method)0L,(method)0L,calcoffset(t_jit_ys_spring,k));	jit_class_addattr(_jit_ys_spring_class,attr);		attr = jit_object_new(_jit_sym_jit_attr_offset,"d",_jit_sym_float32,attrflags,		(method)0L,(method)0L,calcoffset(t_jit_ys_spring,d));	jit_class_addattr(_jit_ys_spring_class,attr);		attr = jit_object_new(_jit_sym_jit_attr_offset,"gravity_x",_jit_sym_float32,attrflags,		(method)0L,(method)0L,calcoffset(t_jit_ys_spring,gravity_x));	jit_class_addattr(_jit_ys_spring_class,attr);		attr = jit_object_new(_jit_sym_jit_attr_offset,"gravity_y",_jit_sym_float32,attrflags,		(method)0L,(method)0L,calcoffset(t_jit_ys_spring,gravity_y));	jit_class_addattr(_jit_ys_spring_class,attr);		attr = jit_object_new(_jit_sym_jit_attr_offset,"dragCoeff",_jit_sym_float32,attrflags,		(method)0L,(method)0L,calcoffset(t_jit_ys_spring,dragCoeff));	jit_class_addattr(_jit_ys_spring_class,attr);		attr = jit_object_new(_jit_sym_jit_attr_offset,"dt",_jit_sym_float32,attrflags,		(method)0L,(method)0L,calcoffset(t_jit_ys_spring,dt));	jit_class_addattr(_jit_ys_spring_class,attr);			attr = jit_object_new(_jit_sym_jit_attr_offset,"forceMask",_jit_sym_char,attrflags,		(method)0L,(method)0L,calcoffset(t_jit_ys_spring,forceMask));	jit_class_addattr(_jit_ys_spring_class,attr);			attr = jit_object_new(_jit_sym_jit_attr_offset,"floor",_jit_sym_float32,attrflags,		(method)0L,(method)0L,calcoffset(t_jit_ys_spring,floor));	jit_class_addattr(_jit_ys_spring_class,attr);				jit_class_register(_jit_ys_spring_class);	return JIT_ERR_NONE;}t_jit_err jit_ys_spring_matrix_calc(t_jit_ys_spring *x, void *inputs, void *outputs){	t_jit_err err=JIT_ERR_NONE;	long in_savelock,out_savelock, param_savelock;	t_jit_matrix_info in_minfo,out_minfo, param_minfo;	char *in_bp,*out_bp, *param_bp;	long i,dimcount,planecount,dim[JIT_MATRIX_MAX_DIMCOUNT];	void *in_matrix,*out_matrix, *param_matrix;		in_matrix 	= jit_object_method(inputs,_jit_sym_getindex,0);			// 1st matrix	param_matrix 	= jit_object_method(inputs,_jit_sym_getindex,1);	out_matrix 	= jit_object_method(outputs,_jit_sym_getindex,0);		// 1st matrix	if (x&&in_matrix&&out_matrix&&param_matrix) {		in_savelock = (long) jit_object_method(in_matrix,_jit_sym_lock,1); 		param_savelock = (long) jit_object_method(out_matrix,_jit_sym_lock,1);		out_savelock = (long) jit_object_method(out_matrix,_jit_sym_lock,1);				jit_object_method(in_matrix,_jit_sym_getinfo,&in_minfo);		jit_object_method(param_matrix,_jit_sym_getinfo,&param_minfo);		jit_object_method(out_matrix,_jit_sym_getinfo,&out_minfo);				jit_object_method(in_matrix,_jit_sym_getdata,&in_bp);		jit_object_method(param_matrix,_jit_sym_getdata,&param_bp);		jit_object_method(out_matrix,_jit_sym_getdata,&out_bp);				if (!in_bp) { err=JIT_ERR_INVALID_INPUT; goto out;}		if (!param_bp) { err=JIT_ERR_INVALID_OUTPUT; goto out;}		if (!out_bp) { err=JIT_ERR_INVALID_OUTPUT; goto out;}				//compatible types?		if ((in_minfo.type!=out_minfo.type)) { 			err=JIT_ERR_MISMATCH_TYPE; 			goto out;		}				//compatible planes?		if (in_minfo.planecount!=out_minfo.planecount) {			err=JIT_ERR_MISMATCH_PLANE; 			goto out;		}		//get dimensions/planecount		dimcount   = out_minfo.dimcount;		planecount = out_minfo.planecount;					for (i=0;i<dimcount;i++) {			dim[i] = MIN(in_minfo.dim[i],out_minfo.dim[i]);		}				// set Matrix info		x->matrix.mp = (uchar *)param_bp;		x->matrix.width = param_minfo.dim[0];		x->matrix.height = param_minfo.dim[1];		x->matrix.dimstride = param_minfo.dimstride[1];		//calculate		jit_ys_spring_calculate_ndim(x, dimcount, dim, planecount, &in_minfo, in_bp, &out_minfo, out_bp);			} else {		return JIT_ERR_INVALID_PTR;	}	out:	jit_object_method(out_matrix,_jit_sym_lock,out_savelock);	jit_object_method(in_matrix,_jit_sym_lock,in_savelock);	return err;}//recursive function to handle higher dimension matrices, by processing 2D sections at a time t_jit_err jit_ys_spring_calculate_ndim(t_jit_ys_spring *x, long dimcount, long *dim, long planecount, 	t_jit_matrix_info *in_minfo, char *bip, t_jit_matrix_info *out_minfo, char *bop){	long i, j, width, height;	uchar *ip, *op;			if (dimcount<1) return 0; //safety	switch(dimcount) {	case 1:		//dim[1] = 1;		if(planecount == 10)			Evaluate(bip, bop, dim[0], x);		else			post("dim->1 but planecount is not 10");		break;	case 2:		width = dim[0];		height = dim[1];				if (in_minfo->type==_jit_sym_char) {			switch (planecount) {			case 1:	// Grayscale				/*for (i=0; i<height; i++){					ip = bip + i*in_minfo->dimstride[1];		// dimstride[1] == width (bytes)					op = bop  + i*out_minfo->dimstride[1];										for(j=0; j<width; j++){						op[j] = ip[j];	// (i, j)					}				}				*/				post("warning: plane count .. 1");				return 1;				break;							case 2:				//Evaluate(bip, bop, in_minfo->dimstride[1], width, height, x->param);				return 1;				break;							case 4:	// 4 plane (ARGB)				/*				for (i=0; i<height; i++){					long *ipp = bip + i*in_minfo->dimstride[1];	// dimstride[1] == width*4 (bytes)					long *opp = bop  + i*out_minfo->dimstride[1];										for(j=0; j<width; j++, ipp++, opp++){						ip = ipp;						op = opp;												op[0] = ip[0];	// alpha												switch(1){							case 1:								op[1] = ip[2];	// R <-G								op[2] = ip[3];	// G <- B								op[3] = ip[1];	// B <- R								break;							case 2:								op[1] = ip[3];	// R <- B								op[2] = ip[1];	// G <- R								op[3] = ip[2];	// B <- G								break;							default:								op[1] = ip[1];	// R <- R								op[2] = ip[2];	// G <- G								op[3] = ip[3];	// B <- B								break;						}							}				}				*/				post("warning: plane count .. 4");				return 1;								break;			default:/*				for (i=0; i<height; i++){					ip = bip + i*in_minfo->dimstride[1];					op = bop  + i*out_minfo->dimstride[1];									}*/				post("warning: plane count .. default");				return 1;				break;			}		}		break;			default:		break;		//for(i=0; i<dim[dimcount-1]; i++) {		//	ip = bip + i*in_minfo->dimstride[dimcount-1];	//		op = bop + i*out_minfo->dimstride[dimcount-1];	//	}	}	return 0;}t_jit_ys_spring *jit_ys_spring_new(void){	t_jit_ys_spring *x;	long i;			if (x=(t_jit_ys_spring *)jit_object_alloc(_jit_ys_spring_class)) {		// attributes initialization			//x->param[0] = 1.0f;		//for(i=1; i<6; i++) x->param[i] = 0.0f;				x->len = 1.0f;		x->k = 1.0f;		x->d = 1.0f;		x->gravity_x = 0.0f;		x->gravity_y = 1.0f;		x->dragCoeff = 1.0f;		x->dt = 1.0f;				x->psinfo.p = & x->particle;		x->psinfo.pnum = 100;		x->psinfo.s = & x->spring;		x->psinfo.snum = 99;						x->floor = 235.0f;							} else {		x = NULL;	}		return x;}void jit_ys_spring_free(t_jit_ys_spring *x){	//nada}