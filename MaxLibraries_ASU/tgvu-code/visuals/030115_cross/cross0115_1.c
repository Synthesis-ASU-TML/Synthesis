//	cross0115.c////	cross point//	////													01.15.03 by seri//////////////////////////////////////////////////////////////////////////////////////////////* starting point for a Max external object ------- *//* the required include file(s) */#include "ext.h"/* structure definition of your object */typedef struct cross0115 {	// required header	t_object m_ob;						// example field: an outlet	void *m_out;	void *m_out_flag;		// position	long ax, ay, bx, by, cx, cy, dx, dy;	} Cross0115;/* globalthat holds the class definition */void *cross0115_class;/* prototypes for your functions */void cross0115_bang(Cross0115 *x);void *cross0115_new();void cross0115_free(Cross0115 *x);void getPos(Cross0115 *x, t_symbol *msg, short argc, t_atom *argv);float distance(int x1, int y1, int x2, int y2);//void setOffsetVal(t_atom *ov, long n);/* initialization routine */void main(fptr *f){	/* tell Max about your class. */	setup((Messlist **)&cross0115_class, (method)cross0115_new, (method)cross0115_free,			(short)sizeof(Cross0115), 0L, 0);		/* bind your methods to symbols */	addbang((method)cross0115_bang);	addmess((method)getPos, "list", A_GIMME, 0);}void getPos(Cross0115 *x, t_symbol *msg, short argc, t_atom *argv){	if(argc == 8 && argv[0].a_type == A_LONG && argv[1].a_type == A_LONG){		x->ax = argv[0].a_w.w_long;		x->ay = argv[1].a_w.w_long;		x->bx = argv[2].a_w.w_long;		x->by = argv[3].a_w.w_long;		x->cx = argv[4].a_w.w_long;		x->cy = argv[5].a_w.w_long;		x->dx = argv[6].a_w.w_long;		x->dy = argv[7].a_w.w_long;	}}void cross0115_bang(Cross0115 *x){	t_atom ov[2];		float s, t;	long ax, ay, bx, by, cx, cy, dx, dy;	long cross_x, cross_y;	long a, b, c, d, e, f, g;		ax = x->ax;	ay = x->ay;	bx = x->bx;	by = x->by;	cx = x->cx;	cy = x->cy;	dx = x->dx;	dy = x->dy;		a = ax - bx;	c = ay - by;	b = dx - cx;	d = dy - cy;	e = dx - bx;	f = dy - by;		g = a*d - b*c;	if(g == 0){		outlet_int(x->m_out_flag, 0);		return;	}		s = (float)(d*e - b*f)/(float)g;	t = (float)(a*f - c*e)/(float)g;		if(s < 1.0 || t < 1.0){		outlet_int(x->m_out_flag, 2);		return;	}		cross_x = (1.0 - s)*(float)bx + s*(float)ax;	cross_y = (1.0 - s)*(float)by + s*(float)ay;			SETLONG(&ov[0], cross_x);	SETLONG(&ov[1], cross_y);				outlet_int(x->m_out_flag, 1);	outlet_list(x->m_out, 0L, 2, ov);	}//// instance creation routine//void *cross0115_new(){	Cross0115 *x;		// create an instance	x = newobject(cross0115_class);		// create outlet	x->m_out_flag = intout(x);	x->m_out = listout(x);						return (x);							// return newly created object to caller}void cross0115_free(Cross0115 *x){}