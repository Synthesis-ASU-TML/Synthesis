////	jit.ys.hermite.c//						05.26.03	by Yoichiro Serita#include "jit.common.h"#define INVALID -9999.0typedef struct _jit_ys_hermite {	t_object				ob;		float tightness;		float h1[10], h2[10], h3[10], h4[10];	} t_jit_ys_hermite;void *_jit_ys_hermite_class;t_jit_ys_hermite *jit_ys_hermite_new(void);void jit_ys_hermite_free(t_jit_ys_hermite *x);t_jit_err jit_ys_hermite_matrix_calc(t_jit_ys_hermite *x, void *inputs, void *outputs);t_jit_err jit_ys_hermite_calculate_ndim(t_jit_ys_hermite *x, 	t_jit_matrix_info *in_minfo, char *bip, t_jit_matrix_info *out_minfo, char *bop);t_jit_err jit_ys_hermite_init(void);void Evaluate(float *bip, long iwidth, float *bop, long owidth, long oheight, long dimstride, t_jit_ys_hermite *x){	long i, j;	long val;	float tanx[256], tany[256];	float px = -1.0f;	float py = -1.0f;            	for(j=0; j<oheight; j++){		float  *op = bop  + j*dimstride;		for( i=0; i<owidth*2; i++) *op++ = INVALID;	}		// calc tangent	for(i=0; i<iwidth; i++){		if(i  == 0){			tanx[0] = bip[2] - bip[0];			tany[0] = bip[3] - bip[1];				}		else if(i == iwidth-1){			tanx[i] = bip[i*2] - bip[(i-1)*2];			tany[i] = bip[i*2+1] - bip[(i-1)*2 + 1];		}		else{			tanx[i] = bip[(i+1)*2] - bip[(i-1)*2];			tany[i] = bip[(i+1)*2+1] - bip[(i-1)*2 + 1];					}				tanx[i] *= x->tightness;		tany[i] *= x->tightness;	}		// between points	for(i=0; i<iwidth-1; i++){		for(j=0; j<10; j++){			float ix, iy;			ix = x->h1[j] * bip[i*2] + x->h2[j] * bip[(i+1)*2] + x->h3[j] * tanx[i] + x->h4[j] * tanx[i+1];			iy = x->h1[j] * bip[i*2+1] + x->h2[j] * bip[(i+1)*2+1] + x->h3[j] * tany[i] + x->h4[j] * tany[i+1];						if(ix != px || iy != py){				*bop++ = ix;				*bop++ = iy;			}					px = ix;			py = iy;		}	}}t_jit_err jit_ys_hermite_init(void) {	long attrflags=0;	t_jit_object *attr;	t_jit_object *mop, *o;		_jit_ys_hermite_class = jit_class_new("jit_ys_hermite",(method)jit_ys_hermite_new,(method)jit_ys_hermite_free,		sizeof(t_jit_ys_hermite),A_CANT,0L); //A_CANT = untyped	// add mop	mop = jit_object_new(_jit_sym_jit_mop,1,1);	// 1 matrix input / 1 matrix output		jit_class_addadornment(_jit_ys_hermite_class,mop);		// add methods	jit_class_addmethod(_jit_ys_hermite_class, (method)jit_ys_hermite_matrix_calc, "matrix_calc", A_CANT, 0L);	// add attributes (long array)	attrflags = JIT_ATTR_GET_DEFER_LOW | JIT_ATTR_SET_USURP_LOW;	attr = jit_object_new(_jit_sym_jit_attr_offset,"tightness",_jit_sym_float32,attrflags,		(method)0L,(method)0L,calcoffset(t_jit_ys_hermite,tightness));	jit_class_addattr(_jit_ys_hermite_class,attr);			jit_class_register(_jit_ys_hermite_class);	return JIT_ERR_NONE;}t_jit_err jit_ys_hermite_matrix_calc(t_jit_ys_hermite *x, void *inputs, void *outputs){	t_jit_err err=JIT_ERR_NONE;	long in_savelock,out_savelock;	t_jit_matrix_info in_minfo,out_minfo;	char *in_bp,*out_bp;	long i,dimcount,planecount,dim[JIT_MATRIX_MAX_DIMCOUNT];	void *in_matrix,*out_matrix;		in_matrix 	= jit_object_method(inputs,_jit_sym_getindex,0);			// 1st matrix	out_matrix 	= jit_object_method(outputs,_jit_sym_getindex,0);		// 1st matrix	if (x&&in_matrix&&out_matrix) {		in_savelock = (long) jit_object_method(in_matrix,_jit_sym_lock,1); 		out_savelock = (long) jit_object_method(out_matrix,_jit_sym_lock,1);				jit_object_method(in_matrix,_jit_sym_getinfo,&in_minfo);		jit_object_method(out_matrix,_jit_sym_getinfo,&out_minfo);				jit_object_method(in_matrix,_jit_sym_getdata,&in_bp);		jit_object_method(out_matrix,_jit_sym_getdata,&out_bp);				if (!in_bp) { err=JIT_ERR_INVALID_INPUT; goto out;}		if (!out_bp) { err=JIT_ERR_INVALID_OUTPUT; goto out;}				//calculate		jit_ys_hermite_calculate_ndim(x, &in_minfo, in_bp, &out_minfo, out_bp);			} else {		return JIT_ERR_INVALID_PTR;	}	out:	jit_object_method(out_matrix,_jit_sym_lock,out_savelock);	jit_object_method(in_matrix,_jit_sym_lock,in_savelock);	return err;}//recursive function to handle higher dimension matrices, by processing 2D sections at a time t_jit_err jit_ys_hermite_calculate_ndim(t_jit_ys_hermite *x,	t_jit_matrix_info *in_minfo, char *bip, t_jit_matrix_info *out_minfo, char *bop){	Evaluate(bip, in_minfo->dim[0], bop, out_minfo->dim[0], out_minfo->dim[1],					out_minfo->dimstride[1], x);			return 0;}t_jit_ys_hermite *jit_ys_hermite_new(void){	t_jit_ys_hermite *x;	long i;			if (x=(t_jit_ys_hermite *)jit_object_alloc(_jit_ys_hermite_class)) {		// attributes initialization			x->tightness = 0.5f;				for(i=0; i<10; i++){			float t = (float)i * 0.1f;			float t2 = t * t;			float t3 = t2 * t;						x->h1[i] = 2*t3 - 3*t2 + 1;			x->h2[i] = -2*t3 + 3*t2;			x->h3[i] = t3 - 2*t2 +  t;			x->h4[i] = t3 - t2;			}	} else {		x = NULL;	}		return x;}void jit_ys_hermite_free(t_jit_ys_hermite *x){	//nada}