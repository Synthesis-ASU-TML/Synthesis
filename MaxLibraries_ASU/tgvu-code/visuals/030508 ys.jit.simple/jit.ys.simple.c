////	jit.ys.simple.c//						05.08.03	by Yoichiro Serita#include "jit.common.h"typedef struct _jit_ys_simple {	t_object				ob;	char					mode;	long					map[JIT_MATRIX_MAX_PLANECOUNT];		// list input test	long					mapcount;							// list input test} t_jit_ys_simple;void *_jit_ys_simple_class;t_jit_ys_simple *jit_ys_simple_new(void);void jit_ys_simple_free(t_jit_ys_simple *x);t_jit_err jit_ys_simple_matrix_calc(t_jit_ys_simple *x, void *inputs, void *outputs);t_jit_err jit_ys_simple_calculate_ndim(t_jit_ys_simple *x, long dimcount, long *dim, long planecount, 	t_jit_matrix_info *in_minfo, char *bip, t_jit_matrix_info *out_minfo, char *bop);t_jit_err jit_ys_simple_init(void);t_jit_err jit_ys_simple_init(void) {	long attrflags=0;	t_jit_object *attr;	t_jit_object *mop;		_jit_ys_simple_class = jit_class_new("jit_ys_simple",(method)jit_ys_simple_new,(method)jit_ys_simple_free,		sizeof(t_jit_ys_simple),A_CANT,0L); //A_CANT = untyped	// add mop	mop = jit_object_new(_jit_sym_jit_mop,1,1);	// 1 matrix input / 1 matrix output	jit_class_addadornment(_jit_ys_simple_class,mop);		// add methods	jit_class_addmethod(_jit_ys_simple_class, (method)jit_ys_simple_matrix_calc, "matrix_calc", A_CANT, 0L);		// add attributes (char)	attrflags = JIT_ATTR_GET_DEFER_LOW | JIT_ATTR_SET_USURP_LOW;		attr = jit_object_new(_jit_sym_jit_attr_offset,"mode",_jit_sym_char,attrflags,		(method)0L,(method)0L,calcoffset(t_jit_ys_simple,mode));	jit_class_addattr(_jit_ys_simple_class,attr);		// add attributes (long array)	attrflags = JIT_ATTR_GET_DEFER_LOW | JIT_ATTR_SET_USURP_LOW;		attr = jit_object_new(_jit_sym_jit_attr_offset_array,"map",_jit_sym_long,		JIT_MATRIX_MAX_PLANECOUNT, attrflags,(method)0L,(method)0L,		calcoffset(t_jit_ys_simple,mapcount),calcoffset(t_jit_ys_simple,map));	jit_class_addattr(_jit_ys_simple_class,attr);				jit_class_register(_jit_ys_simple_class);	return JIT_ERR_NONE;}t_jit_err jit_ys_simple_matrix_calc(t_jit_ys_simple *x, void *inputs, void *outputs){	t_jit_err err=JIT_ERR_NONE;	long in_savelock,out_savelock;	t_jit_matrix_info in_minfo,out_minfo;	char *in_bp,*out_bp;	long i,dimcount,planecount,dim[JIT_MATRIX_MAX_DIMCOUNT];	void *in_matrix,*out_matrix;		in_matrix 	= jit_object_method(inputs,_jit_sym_getindex,0);			// 1st matrix	out_matrix 	= jit_object_method(outputs,_jit_sym_getindex,0);		// 1st matrix	if (x&&in_matrix&&out_matrix) {		in_savelock = (long) jit_object_method(in_matrix,_jit_sym_lock,1); 		out_savelock = (long) jit_object_method(out_matrix,_jit_sym_lock,1);				jit_object_method(in_matrix,_jit_sym_getinfo,&in_minfo);		jit_object_method(out_matrix,_jit_sym_getinfo,&out_minfo);				jit_object_method(in_matrix,_jit_sym_getdata,&in_bp);		jit_object_method(out_matrix,_jit_sym_getdata,&out_bp);				if (!in_bp) { err=JIT_ERR_INVALID_INPUT; goto out;}		if (!out_bp) { err=JIT_ERR_INVALID_OUTPUT; goto out;}				//compatible types?		if ((in_minfo.type!=out_minfo.type)) { 			err=JIT_ERR_MISMATCH_TYPE; 			goto out;		}				//compatible planes?		if (in_minfo.planecount!=out_minfo.planecount) {			err=JIT_ERR_MISMATCH_PLANE; 			goto out;		}		//get dimensions/planecount		dimcount   = out_minfo.dimcount;		planecount = out_minfo.planecount;					for (i=0;i<dimcount;i++) {			dim[i] = MIN(in_minfo.dim[i],out_minfo.dim[i]);		}				//calculate		jit_ys_simple_calculate_ndim(x, dimcount, dim, planecount, &in_minfo, in_bp, &out_minfo, out_bp);			} else {		return JIT_ERR_INVALID_PTR;	}	out:	jit_object_method(out_matrix,_jit_sym_lock,out_savelock);	jit_object_method(in_matrix,_jit_sym_lock,in_savelock);	return err;}//recursive function to handle higher dimension matrices, by processing 2D sections at a time t_jit_err jit_ys_simple_calculate_ndim(t_jit_ys_simple *x, long dimcount, long *dim, long planecount, 	t_jit_matrix_info *in_minfo, char *bip, t_jit_matrix_info *out_minfo, char *bop){	long i, j, width, height;	uchar *ip, *op;			if (dimcount<1) return 0; //safety	switch(dimcount) {	case 1:		dim[1] = 1;	case 2:		width = dim[0];		height = dim[1];				if (in_minfo->type==_jit_sym_char) {			switch (planecount) {			case 1:	// Grayscale				for (i=0; i<height; i++){					ip = bip + i*in_minfo->dimstride[1];		// dimstride[1] == width (bytes)					op = bop  + i*out_minfo->dimstride[1];										for(j=0; j<width; j++){						op[j] = ip[j];	// (i, j)					}				}				return 1;				break;							case 4:	// 4 plane (ARGB)				for (i=0; i<height; i++){					long *ipp = bip + i*in_minfo->dimstride[1];	// dimstride[1] == width*4 (bytes)					long *opp = bop  + i*out_minfo->dimstride[1];										for(j=0; j<width; j++, ipp++, opp++){						ip = ipp;						op = opp;												op[0] = ip[0];	// alpha												switch(x->mode){							case 1:								op[1] = ip[2];	// R <-G								op[2] = ip[3];	// G <- B								op[3] = ip[1];	// B <- R								break;							case 2:								op[1] = ip[3];	// R <- B								op[2] = ip[1];	// G <- R								op[3] = ip[2];	// B <- G								break;							default:								op[1] = ip[1];	// R <- R								op[2] = ip[2];	// G <- G								op[3] = ip[3];	// B <- B								break;						}							}				}				return 1;				break;			default:				for (i=0; i<height; i++){					ip = bip + i*in_minfo->dimstride[1];					op = bop  + i*out_minfo->dimstride[1];									}				return 1;				break;			}		}		break;			default:		for(i=0; i<dim[dimcount-1]; i++) {			ip = bip + i*in_minfo->dimstride[dimcount-1];			op = bop + i*out_minfo->dimstride[dimcount-1];		}	}	return 0;}t_jit_ys_simple *jit_ys_simple_new(void){	t_jit_ys_simple *x;	long i;			if (x=(t_jit_ys_simple *)jit_object_alloc(_jit_ys_simple_class)) {		// attributes initialization		x->mode = 0;		for(i=0; i<JIT_MATRIX_MAX_PLANECOUNT; i++) x->map[i] = 0;	} else {		x = NULL;	}		return x;}void jit_ys_simple_free(t_jit_ys_simple *x){	//nada}