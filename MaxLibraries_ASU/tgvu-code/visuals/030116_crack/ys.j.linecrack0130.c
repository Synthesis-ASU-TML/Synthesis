//	j_selfforce0124.c////	Self Force (with jitter SDK)//	////													01.24.03 by yoichiro/////////////////////////////////////////////////////////////////////////////////////////////#include "jit.common.h"typedef struct _max_jit_selfforce {	t_object			ob;	void				*obex;	void 				*bangout;	t_symbol			*matrix_name;		} t_max_jit_selfforce;void *max_jit_selfforce_new(t_symbol *s, long argc, t_atom *argv);void max_jit_selfforce_free(t_max_jit_selfforce *x);void max_jit_selfforce_assist(t_max_jit_selfforce *x, void *b, long m, long a, char *s);void max_jit_selfforce_list(t_max_jit_selfforce *x, t_symbol *s, long argc, t_atom *argv);//void linecrack_bang(t_max_jit_selfforce *x);void *max_jit_selfforce_class;		 	t_symbol *ps_done;void main(void){		long attrflags;	void *p,*attr;		setup(&max_jit_selfforce_class, max_jit_selfforce_new, (method)max_jit_selfforce_free, (short)sizeof(t_max_jit_selfforce), 		0L, A_GIMME, 0);	p = max_jit_classex_setup(calcoffset(t_max_jit_selfforce,obex));		// add method	max_addmethod_usurp_low((method)max_jit_selfforce_list, "list");		//addbang((method)linecrack_bang);	// add attribute 	attrflags = JIT_ATTR_GET_USURP_LOW | JIT_ATTR_SET_USURP_LOW ;	attr = jit_object_new(_jit_sym_jit_attr_offset,"matrix_name",_jit_sym_symbol,attrflags,		(method)0L,(method)0L,calcoffset(t_max_jit_selfforce,matrix_name));	max_jit_classex_addattr(p,attr);		max_jit_classex_standard_wrap(p,NULL,0);		addmess((method)max_jit_selfforce_assist,			"assist",			A_CANT,0);}/*long mysqrt(long f){	long next = f, current;	int i;		if(f == 0) return f;	do{		current = next;		next = (current + f / current) >> 1;		}while(next < current);		return current;}*/long distance(int x1, int y1, int x2, int y2){	int dx = x2 - x1;	int dy = y2 - y1;	return dx*dx + dy*dy;	//return mysqrt(dx*dx + dy*dy);	}void setMatrixChar(void* matrix, long index, uchar val){	t_jit_matrix_info minfo;	char *bp;	uchar *p;		// get matrix info (dim & pointer)	jit_object_method(matrix,_jit_sym_getinfo, &minfo);	jit_object_method(matrix,_jit_sym_getdata, &bp);	p = (uchar *)(bp + (index/minfo.dim[0])*minfo.dimstride[1] + (index%minfo.dim[0])*minfo.dimstride[0]);	*p = val;}void max_jit_selfforce_list(t_max_jit_selfforce *x, t_symbol *s, long argc, t_atom *argv){	void *matrix;	long i;	long savelock;	long p1x, p1y, p2x, p2y, px, py;	long dist, index, matrixsize;		if (argc && argv) {		// find matrix		matrix = jit_object_findregistered(x->matrix_name);				if (matrix && jit_object_method(matrix, _jit_sym_class_jit_matrix)) {			// lock matrix			savelock = (long) jit_object_method(matrix,_jit_sym_lock,1);						// get parameters			p1x = jit_atom_getlong(argv);			p1y = jit_atom_getlong(argv+1);			p2x = jit_atom_getlong(argv+2);			p2y = jit_atom_getlong(argv+3);						// clear matrix			for(i=0; i<76800; i++) setMatrixChar(matrix, i, 0);						// calc distance			dist = distance(p1x, p1y, p2x, p2y) * 2;						for(i=0; i<dist; i++){				px = (100-i) * p1x + i * p2x;				py = (100-i) * p1y + i * p2y;						px *= 0.01;				py *= 0.01;						if(px < 0 || px > 319 || py < 0 || py > 239) break;						index= px + py * 320;				setMatrixChar(matrix, index, 255);			}											jit_object_method(matrix,_jit_sym_lock,savelock);						} else {			jit_error_sym(x,_jit_sym_err_calculate);		}	}out:	outlet_bang(x->bangout);	return;}/*void linecrack_bang(t_max_jit_selfforce *x){	post("linecrack_bang");}*/void max_jit_selfforce_assist(t_max_jit_selfforce *x, void *b, long m, long a, char *s){	//nada for now}	void max_jit_selfforce_free(t_max_jit_selfforce *x){	//only max object, no jit object	max_jit_obex_free(x);}void *max_jit_selfforce_new(t_symbol *s, long argc, t_atom *argv){	t_max_jit_selfforce *x;	long attrstart;	x = (t_max_jit_selfforce *)max_jit_obex_new(max_jit_selfforce_class,NULL); //only max object, no jit object	max_jit_obex_dumpout_set(x, outlet_new(x,0L)); //general purpose outlet(rightmost)	x->bangout 	= outlet_new(x,0L); // after done, outputs bang		x->matrix_name = _jit_sym_nothing;	attrstart = max_jit_attr_args_offset(argc,argv);	if (attrstart&&argv) {		jit_atom_arg_getsym(&x->matrix_name, 0, attrstart, argv);	}			max_jit_attr_args(x,argc,argv); //handle attribute argsout:		return (x);}