//	linecrack0108.c////	Line Crack//	////													01.08.03 by seri//////////////////////////////////////////////////////////////////////////////////////////////* starting point for a Max external object ------- *//* the required include file(s) */#include "ext.h"/* structure definition of your object */typedef struct linecrack0108 {	// required header	t_object m_ob;						// example field: an outlet	void *m_out;	void *m_out_offset;		// position	long p1x, p1y, p2x, p2y;		// pixel value	Handle h_val;	} LineCrack0108;/* globalthat holds the class definition */void *linecrack0108_class;/* prototypes for your functions */void linecrack0108_bang(LineCrack0108 *x);void *linecrack0108_new();void linecrack0108_free(LineCrack0108 *x);void getPos(LineCrack0108 *x, t_symbol *msg, short argc, t_atom *argv);void setOffsetVal(t_atom *ov, long n);/* initialization routine */void main(fptr *f){	/* tell Max about your class. */	setup((Messlist **)&linecrack0108_class, (method)linecrack0108_new, (method)linecrack0108_free,			(short)sizeof(LineCrack0108), 0L, 0);		/* bind your methods to symbols */	addbang((method)linecrack0108_bang);	addmess((method)getPos, "list", A_GIMME, 0);		//post("linecrack0108 loaded..");}void getPos(LineCrack0108 *x, t_symbol *msg, short argc, t_atom *argv){	if(argc > 1 && argv[0].a_type == A_LONG && argv[1].a_type == A_LONG &&	   argv[2].a_type == A_LONG && argv[3].a_type == A_LONG){		x->p1x = argv[0].a_w.w_long;		x->p1y = argv[1].a_w.w_long;		x->p2x = argv[2].a_w.w_long;		x->p2y = argv[3].a_w.w_long;	}}long distance(int x1, int y1, int x2, int y2){	return (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);}void setOffsetVal(t_atom *ov, long n){	int i, j;	j = n / 320;	i = n - j * 320;	SETLONG(&ov[0], i);	SETLONG(&ov[1], j); }void linecrack0108_bang(LineCrack0108 *x){	int i;	long dist;	int t;	long px, py, pixel;	t_atom ov[2];		// pointer to the array of long for previous value	t_atom *pv = (t_atom *)*x->h_val;		dist = distance(x->p1x, x->p1y, x->p2x, x->p2y) * 2;		for(i=0; i<76800; i++) SETLONG(&pv[i], 0);	for(t=0; t<dist; t++){		px = (100-t) * x->p1x + t * x->p2x;		py = (100-t) * x->p1y + t * x->p2y;				px *= 0.01;		py *= 0.01;				if(px < 0 || px > 319 || py < 0 || py > 239) break;				pixel = px + py * 320;		SETLONG(&pv[pixel], 255);	}		// offset value and pixel value (0-32766, 32767-65533, 65534-76800)	setOffsetVal(ov, 0);	outlet_list(x->m_out_offset, 0L, 2, ov);	outlet_list(x->m_out, 0L, 32767, pv);		setOffsetVal(ov, 32767);	outlet_list(x->m_out_offset, 0L, 2, ov);	outlet_list(x->m_out, 0L, 32767, pv+32767);		setOffsetVal(ov, 65534);	outlet_list(x->m_out_offset, 0L, 2, ov);	outlet_list(x->m_out, 0L, 11266, pv+65534);	}//// instance creation routine//void *linecrack0108_new(){	LineCrack0108 *x;	t_atom *pv;	int i;	long pixelsize;		// create an instance	x = newobject(linecrack0108_class);		// allocate pixel memory	pixelsize = 320 * 240;	x->h_val = newhandle(sizeof(t_atom) * pixelsize); 	pv = (t_atom *)*x->h_val;	for(i=0; i<pixelsize; i++) SETLONG(&pv[i], 0);	// create outlet	x->m_out_offset = intout(x);	x->m_out = listout(x);						return (x);							// return newly created object to caller}void linecrack0108_free(LineCrack0108 *x){	disposhandle(x->h_val);}