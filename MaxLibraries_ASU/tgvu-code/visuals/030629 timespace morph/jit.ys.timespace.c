////	jit.ys.timespace.c//						06.06.03	by Yoichiro Serita#include "jit.common.h"typedef struct _jit_ys_timespace {	t_object				ob;		long x, y, z;	long datasize;	uchar *data;	uchar index;	} t_jit_ys_timespace;void *_jit_ys_timespace_class;t_jit_ys_timespace *jit_ys_timespace_new(void);void jit_ys_timespace_allocate(t_jit_ys_timespace *x, long width, long height);void jit_ys_timespace_free(t_jit_ys_timespace *x);t_jit_err jit_ys_timespace_matrix_calc(t_jit_ys_timespace *x, void *inputs, void *outputs);t_jit_err jit_ys_timespace_calculate_ndim(t_jit_ys_timespace *x, long dimcount, long *dim, long planecount, 	t_jit_matrix_info *in_minfo, char *bip, t_jit_matrix_info *out_minfo, char *bop, t_jit_matrix_info *param_info, char *bpp);t_jit_err jit_ys_timespace_init(void);long getdata(long width, long height, uchar *data, long i, long j, uchar index, uchar nindex, uchar t){	int l;			uchar *bp = data + 4*width*j + 4*i;	long a = 4*width*height;		float k = (float)t/255.;		uchar *p1 = bp + a * index;	uchar *p2 = bp + a * nindex;		long val;	uchar *vp = (uchar *)&val;		for(l=0; l<4; l++)		vp[l] = (1.0 - k) * p1[l] + k * p2[l];		return val;	//return *(long *)(data + 4 * width* height * index + 4 * width * j + 4 * i);	}void Evaluate(t_jit_ys_timespace *x, char *bip, char *bop, long dimstride, long width, long height, char *bpp, long pdim){	long i, j;	long pindex, nindex;   	long *dp;   	   	// increment index   	x->index = (x->index == 255) ? 0 : x->index + 1;          	// copy current frame    	dp = (long *)(x->data + 4 * width * height * x->index);    	    	for(j=0; j<height; j++){    		long *ip = bip + j*dimstride;	// dimstride[1] == width (bytes)			for( i=0; i<width; i++)  *dp++ = *ip++;	}			    	// get pixel by index    	for(j=0; j<height; j++){		long  *op = bop  + j*dimstride;		uchar *pp = bpp + j*pdim;			for( i=0; i<width; i++){			pindex = x->index - pp[i*2];			nindex = pindex - 1;			if(pindex < 0) pindex += 256;			if(nindex < 0) nindex += 256;					op[i] = getdata(width, height, x->data, i, j, (uchar)pindex, (uchar)nindex, pp[i*2+1]);				}    	}}t_jit_err jit_ys_timespace_init(void) {	long attrflags=0;	t_jit_object *attr;	t_jit_object *mop, *o;			_jit_ys_timespace_class = jit_class_new("jit_ys_timespace",(method)jit_ys_timespace_new,(method)jit_ys_timespace_free,		sizeof(t_jit_ys_timespace),A_CANT,0L); //A_CANT = untyped	// add mop	mop = jit_object_new(_jit_sym_jit_mop,2,1);	// 1 matrix input / 1 matrix output	// need this for getting correct matrix_info from 2nd input matrix....  (see jit.concat.c...)	jit_mop_input_nolink(mop,2);	 o= jit_object_method(mop,_jit_sym_getinput,2);	jit_object_method(o,_jit_sym_ioproc,jit_mop_ioproc_copy_adapt); 		jit_class_addadornment(_jit_ys_timespace_class,mop);		// add methods	jit_class_addmethod(_jit_ys_timespace_class, (method)jit_ys_timespace_matrix_calc, "matrix_calc", A_CANT, 0L);	// add attributes (char)	//attrflags = JIT_ATTR_GET_DEFER_LOW | JIT_ATTR_SET_USURP_LOW;		//attr = jit_object_new(_jit_sym_jit_attr_offset,"depth",_jit_sym_long,attrflags,	//	(method)0L,(method)0L,calcoffset(t_jit_ys_timespace,depth));	//jit_class_addattr(_jit_ys_timespace_class,attr);			//attrflags = JIT_ATTR_GET_DEFER_LOW | JIT_ATTR_SET_USURP_LOW;		//attr = jit_object_new(_jit_sym_jit_attr_offset,"index",_jit_sym_char,attrflags,//		(method)0L,(method)0L,calcoffset(t_jit_ys_timespace,index));//	jit_class_addattr(_jit_ys_timespace_class,attr);			jit_class_register(_jit_ys_timespace_class);	return JIT_ERR_NONE;}t_jit_err jit_ys_timespace_matrix_calc(t_jit_ys_timespace *x, void *inputs, void *outputs){	t_jit_err err=JIT_ERR_NONE;	long in_savelock,out_savelock,param_savelock;	t_jit_matrix_info in_minfo,out_minfo, param_minfo;	char *in_bp,*out_bp, *param_bp;	long i,dimcount,planecount,dim[JIT_MATRIX_MAX_DIMCOUNT];	void *in_matrix,*out_matrix, *param_matrix;		in_matrix 	= jit_object_method(inputs,_jit_sym_getindex,0);			// 1st matrix	param_matrix 	= jit_object_method(inputs,_jit_sym_getindex,1);			// 2nd matrix (parameter)	out_matrix 	= jit_object_method(outputs,_jit_sym_getindex,0);		// 1st matrix		if (x&&in_matrix&&out_matrix&&param_matrix) {		in_savelock = (long) jit_object_method(in_matrix,_jit_sym_lock,1); 		param_savelock = (long) jit_object_method(out_matrix,_jit_sym_lock,1);		out_savelock = (long) jit_object_method(out_matrix,_jit_sym_lock,1);						jit_object_method(in_matrix,_jit_sym_getinfo,&in_minfo);		jit_object_method(param_matrix,_jit_sym_getinfo,&param_minfo);		jit_object_method(out_matrix,_jit_sym_getinfo,&out_minfo);						jit_object_method(in_matrix,_jit_sym_getdata,&in_bp);		jit_object_method(param_matrix,_jit_sym_getdata,&param_bp);		jit_object_method(out_matrix,_jit_sym_getdata,&out_bp);						if (!in_bp) { err=JIT_ERR_INVALID_INPUT; goto out;}		if (!out_bp) { err=JIT_ERR_INVALID_OUTPUT; goto out;}		if (!param_bp) { err=JIT_ERR_INVALID_OUTPUT; goto out;}				//compatible types?		if ((in_minfo.type!=out_minfo.type)) { 			err=JIT_ERR_MISMATCH_TYPE; 			goto out;		}				//compatible planes?		if (in_minfo.planecount!=out_minfo.planecount) {			err=JIT_ERR_MISMATCH_PLANE; 			goto out;		}				//if(param_minfo.planecount != 6){		//	err=JIT_ERR_MISMATCH_PLANE; 		//	goto out;		//}				//get dimensions/planecount		dimcount   = out_minfo.dimcount;		planecount = out_minfo.planecount;					for (i=0;i<dimcount;i++) {			dim[i] = MIN(in_minfo.dim[i],out_minfo.dim[i]);		}				//calculate		jit_ys_timespace_calculate_ndim(x, dimcount, dim, planecount, &in_minfo, in_bp, &out_minfo, out_bp, &param_minfo, param_bp);			} else {		return JIT_ERR_INVALID_PTR;	}	out:	jit_object_method(out_matrix,_jit_sym_lock,out_savelock);	jit_object_method(in_matrix,_jit_sym_lock,in_savelock);	jit_object_method(param_matrix,_jit_sym_lock,param_savelock);	return err;}//recursive function to handle higher dimension matrices, by processing 2D sections at a time t_jit_err jit_ys_timespace_calculate_ndim(t_jit_ys_timespace *x, long dimcount, long *dim, long planecount, 	t_jit_matrix_info *in_minfo, char *bip, t_jit_matrix_info *out_minfo, char *bop, t_jit_matrix_info *param_minfo, char *bpp) {	long i, j, width, height;	uchar *ip, *op;			if (dimcount<1) return 0; //safety	switch(dimcount) {	case 1:		dim[1] = 1;	case 2:		width = dim[0];		height = dim[1];				if (in_minfo->type==_jit_sym_char) {			switch (planecount) {			case 1:				post("warning: plane count .. 1");				return 1;				break;							case 2:				post("warning: plane count .. 2");				return 1;				break;							case 4:	// 4 plane (ARGB)				if(width * height > x->x * x->y){					jit_ys_timespace_free(x);					jit_ys_timespace_allocate(x, width, height);				}									Evaluate(x, bip, bop, in_minfo->dimstride[1], width, height, bpp, param_minfo->dimstride[1]);				break;							default:				post("warning: plane count .. default");				return 1;				break;			}		}		break;			default:		break;	}	return 0;}void jit_ys_timespace_allocate(t_jit_ys_timespace *x, long width, long height){	x->x = width;	x->y = height;	x->datasize = 4 * x->x *x->y * x->z;	x->data = (uchar *)jit_getbytes(x->datasize); 	}t_jit_ys_timespace *jit_ys_timespace_new(void){	t_jit_ys_timespace *x;	long i;			if (x=(t_jit_ys_timespace *)jit_object_alloc(_jit_ys_timespace_class)) {			// attributes initialization		x->index = 255;		x->z= 256;		jit_ys_timespace_allocate(x, 320, 240);		for(i=0; i<x->datasize; i++) x->data[i] = 0;			} else {		x = NULL;	}		return x;}void jit_ys_timespace_free(t_jit_ys_timespace *x){	if(x->data) jit_freebytes(x->data, x->datasize);}