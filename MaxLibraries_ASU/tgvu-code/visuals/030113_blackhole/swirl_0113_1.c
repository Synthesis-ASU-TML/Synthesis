//	selfforce1225.c////	Energy force field//	////													12.25.02 by seri////	//	inlet1 (bang)			calculate energy in each pixel and send out offset and list//	inlet1 (list)	x y		position//	inlet2 (int)	k		parameter (default: 50)////	outlet1 (list)			pixel value list (to jit.fill)//	outlet2 (int)	py		pixel offset (to jit.fill)//////////////////////////////////////////////////////////////////////////////////////////////* starting point for a Max external object ------- *//* the required include file(s) */#include <math.h>#include "ext.h"/* structure definition of your object */typedef struct selfforce1225 {	// required header	t_object m_ob;						// example field: an outlet	void *m_out;	void *m_out_offset;		//Handle h_val;		// position	long px, py;		// parameter	long kd, kr;		// pixel value	Handle h_val, h_val2;	} SelfForce1225;/* globalthat holds the class definition */void *selfforce1225_class;/* prototypes for your functions */void selfforce1225_bang(SelfForce1225 *x);void *selfforce1225_new();void selfforce1225_free(SelfForce1225 *x);void getPos(SelfForce1225 *x, t_symbol *msg, short argc, t_atom *argv);void getParam1(SelfForce1225 *x, long k);void getParam2(SelfForce1225 *x, long k);float distance(int x1, int y1, int x2, int y2);//void setOffsetVal(t_atom *ov, long n);/* initialization routine */void main(fptr *f){	/* tell Max about your class. */	setup((Messlist **)&selfforce1225_class, (method)selfforce1225_new, (method)selfforce1225_free,			(short)sizeof(SelfForce1225), 0L, 0);		/* bind your methods to symbols */	addbang((method)selfforce1225_bang);	addmess((method)getPos, "list", A_GIMME, 0);	addinx((method)getParam1, 1);	addinx((method)getParam2, 2);		// post("selfforce1225 loaded..");}void getPos(SelfForce1225 *x, t_symbol *msg, short argc, t_atom *argv){	if(argc == 2 && argv[0].a_type == A_LONG && argv[1].a_type == A_LONG){		x->px = argv[0].a_w.w_long;		x->py = argv[1].a_w.w_long;	}}void getParam1(SelfForce1225 *x, long k){	x->kd = k;}void getParam2(SelfForce1225 *x, long k){	x->kr = k;}float distance(int x1, int y1, int x2, int y2){	return (float)sqrt(pow(x2-x1, 2) + pow(y2-y1, 2));}void setOffsetVal(t_atom *ov, int pn, long n){	int i, j;	j = n / 320;	i = n - j * 320;	SETLONG(&ov[0], pn);	SETLONG(&ov[1], i);	SETLONG(&ov[2], j); }void selfforce1225_bang(SelfForce1225 *x){	int i,j;	int index = 0;	long dist;	t_atom ov[3];	long p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y;	float cosr, sinr;		// pointer to the array of long for previous value	t_atom *pv = (t_atom *)*x->h_val;	t_atom *pv2 = (t_atom *)*x->h_val2;		for(j=0; j<240; j++){		for(i=0; i<320; i++, index++){			// calc distance from pixel to each person			dist = distance(i, j, x->px, x->py);							p1x = i - x->px;			p1y = j - x->py;						p2x = p1x * (float)x->kd/100;			p2y = p1y * (float)x->kd/100;						if(dist > 0){				cosr = cos((float)x->kr/dist);				sinr = sin((float)x->kr/dist);			}			else{				cosr = 1.0;				sinr = 0.0;			}							p3x = cosr * p2x - sinr * p2y;			p3y = sinr * p2x + cosr * p2y;						p4x = p3x + x->px;			p4y = p3y + x->py;						if(p4x < 0) p4x = 0;			if(p4x > 319) p4x = 319;			if(p4y < 0) p4y = 0;			if(p4y > 239) p4y = 319;					// output new value only when the value has changed			SETLONG(&pv[index], p4x);			SETLONG(&pv2[index], p4y);								}	}			// offset value and pixel value (0-32766, 32767-65533, 65534-76800)	setOffsetVal(ov, 0, 0);	outlet_list(x->m_out_offset, 0L, 3, ov);	outlet_list(x->m_out, 0L, 32767, pv);		setOffsetVal(ov, 0, 32767);	outlet_list(x->m_out_offset, 0L, 3, ov);	outlet_list(x->m_out, 0L, 32767, pv+32767);		setOffsetVal(ov, 0, 65534);	outlet_list(x->m_out_offset, 0L, 3, ov);	outlet_list(x->m_out, 0L, 11266, pv+65534);			setOffsetVal(ov, 1, 0);	outlet_list(x->m_out_offset, 0L, 3, ov);	outlet_list(x->m_out, 0L, 32767, pv2);		setOffsetVal(ov, 1, 32767);	outlet_list(x->m_out_offset, 0L, 3, ov);	outlet_list(x->m_out, 0L, 32767, pv2+32767);		setOffsetVal(ov, 1, 65534);	outlet_list(x->m_out_offset, 0L, 3, ov);	outlet_list(x->m_out, 0L, 11266, pv2+65534);	}//// instance creation routine//void *selfforce1225_new(){	SelfForce1225 *x;	t_atom *pv, *pv2;	int i;	long pixelsize;		// create an instance	x = newobject(selfforce1225_class);		// allocate pixel memory	pixelsize = 320 * 240;	x->h_val = newhandle(sizeof(t_atom) * pixelsize);	pv = (t_atom *)*x->h_val;	for(i=0; i<pixelsize; i++) SETLONG(&pv[i], 0);	x->h_val2 = newhandle(sizeof(t_atom) * pixelsize);	pv2 = (t_atom *)*x->h_val2;	for(i=0; i<pixelsize; i++) SETLONG(&pv2[i], 0);			// initialization	//x->k = 50;		// crate inlet	intin(x, 2);	intin(x, 1);		// create outlet	x->m_out_offset = intout(x);	x->m_out = listout(x);						return (x);							// return newly created object to caller}void selfforce1225_free(SelfForce1225 *x){	disposhandle(x->h_val);	disposhandle(x->h_val2);}