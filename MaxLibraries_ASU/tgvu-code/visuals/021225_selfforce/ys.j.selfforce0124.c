//	j_selfforce0124.c////	Self Force (with jitter SDK)//	////													01.24.03 by yoichiro/////////////////////////////////////////////////////////////////////////////////////////////#include "jit.common.h"typedef struct _max_jit_selfforce {	t_object			ob;	void				*obex;	void 				*bangout;	t_symbol			*matrix_name;	} t_max_jit_selfforce;void *max_jit_selfforce_new(t_symbol *s, long argc, t_atom *argv);void max_jit_selfforce_free(t_max_jit_selfforce *x);void max_jit_selfforce_assist(t_max_jit_selfforce *x, void *b, long m, long a, char *s);void max_jit_selfforce_list(t_max_jit_selfforce *x, t_symbol *s, long argc, t_atom *argv);void *max_jit_selfforce_class;		 	t_symbol *ps_done;void main(void){		long attrflags;	void *p,*attr;		setup(&max_jit_selfforce_class, max_jit_selfforce_new, (method)max_jit_selfforce_free, (short)sizeof(t_max_jit_selfforce), 		0L, A_GIMME, 0);	p = max_jit_classex_setup(calcoffset(t_max_jit_selfforce,obex));		// add method	max_addmethod_usurp_low((method)max_jit_selfforce_list, "list");		// add attribute 	attrflags = JIT_ATTR_GET_DEFER_LOW | JIT_ATTR_SET_DEFER_LOW ;	attr = jit_object_new(_jit_sym_jit_attr_offset,"matrix_name",_jit_sym_symbol,attrflags,		(method)0L,(method)0L,calcoffset(t_max_jit_selfforce,matrix_name));	max_jit_classex_addattr(p,attr);		max_jit_classex_standard_wrap(p,NULL,0);		addmess((method)max_jit_selfforce_assist,			"assist",			A_CANT,0);}long mysqrt(long f){	long next = f, current;	int i;		if(f == 0) return f;	do{		current = next;		next = (current + f / current) >> 1;		}while(next < current);		return current;}long distance(int x1, int y1, int x2, int y2){	int dx = x2 - x1;	int dy = y2 - y1;	return mysqrt(dx*dx + dy*dy);	}void max_jit_selfforce_list(t_max_jit_selfforce *x, t_symbol *s, long argc, t_atom *argv){	void *matrix;	long i,j;	long savelock;	t_jit_matrix_info minfo;	char *bp;	uchar *p;	long px, py, pr;	long energy, value, dist;	int index = 0;		if (argc && argv) {		// find matrix		matrix = jit_object_findregistered(x->matrix_name);				if (matrix && jit_object_method(matrix, _jit_sym_class_jit_matrix)) {			// lock matrix			savelock = (long) jit_object_method(matrix,_jit_sym_lock,1);						// get matrix info (dim & pointer)			jit_object_method(matrix,_jit_sym_getinfo,&minfo);			jit_object_method(matrix,_jit_sym_getdata,&bp);			// get parameters			px = jit_atom_getlong(argv);			py = jit_atom_getlong(argv+1);			pr = jit_atom_getlong(argv+2);			for(j=0; j<minfo.dim[1]; j++){			for(i=0; i<minfo.dim[0]; i++, index++){				p = (uchar *)(bp + (index/minfo.dim[0])*minfo.dimstride[1] + (index%minfo.dim[0])*minfo.dimstride[0]);				// calc distance from pixel to each person				dist = distance(i, j, px, py);							if(dist == 0){					*p = 255;					continue;				}							// calc energy				energy = 10000.0f*pr/dist;						// clip & invert (0 is the highest energy)				if(energy >65535) energy = 65535;				else if(energy < 0) energy = 0;				value = energy >> 8;							// output new value only when the value has changed				*p = value;			}			}											jit_object_method(matrix,_jit_sym_lock,savelock);						} else {			jit_error_sym(x,_jit_sym_err_calculate);		}	}out:	outlet_bang(x->bangout);	return;}void max_jit_selfforce_assist(t_max_jit_selfforce *x, void *b, long m, long a, char *s){	//nada for now}	void max_jit_selfforce_free(t_max_jit_selfforce *x){	//only max object, no jit object	max_jit_obex_free(x);}void *max_jit_selfforce_new(t_symbol *s, long argc, t_atom *argv){	t_max_jit_selfforce *x;	long attrstart;	x = (t_max_jit_selfforce *)max_jit_obex_new(max_jit_selfforce_class,NULL); //only max object, no jit object	max_jit_obex_dumpout_set(x, outlet_new(x,0L)); //general purpose outlet(rightmost)	x->bangout 	= outlet_new(x,0L); // after done, outputs bang		x->matrix_name = _jit_sym_nothing;	attrstart = max_jit_attr_args_offset(argc,argv);	if (attrstart&&argv) {		jit_atom_arg_getsym(&x->matrix_name, 0, attrstart, argv);	}			max_jit_attr_args(x,argc,argv); //handle attribute argsout:		return (x);}