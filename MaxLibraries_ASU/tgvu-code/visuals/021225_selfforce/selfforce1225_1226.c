//	selfforce1225.c////	Energy force field//	////													12.25.02 by seri////	//	inlet1 (bang)			calculate energy in each pixel and send out offset and list//	inlet1 (list)	x y		position//	inlet2 (int)	k		parameter (default: 50)////	outlet1 (list)			pixel value list (to jit.fill)//	outlet2 (int)	py		pixel offset (to jit.fill)//////////////////////////////////////////////////////////////////////////////////////////////* starting point for a Max external object ------- *//* the required include file(s) */#include <math.h>#include "ext.h"/* structure definition of your object */typedef struct selfforce1225 {	// required header	t_object m_ob;						// example field: an outlet	void *m_out;	void *m_out_offset;		//Handle h_val;		// position	long px, py;		// parameter	long k;		// pixel value	Handle h_val;	} SelfForce1225;/* globalthat holds the class definition */void *selfforce1225_class;/* prototypes for your functions */void selfforce1225_bang(SelfForce1225 *x);void *selfforce1225_new();void selfforce1225_free(SelfForce1225 *x);void getPos(SelfForce1225 *x, t_symbol *msg, short argc, t_atom *argv);void getParam(SelfForce1225 *x, long k);float distance(int x1, int y1, int x2, int y2);void setOffsetVal(t_atom *ov, long n);/* initialization routine */void main(fptr *f){	/* tell Max about your class. */	setup((Messlist **)&selfforce1225_class, (method)selfforce1225_new, (method)selfforce1225_free,			(short)sizeof(SelfForce1225), 0L, 0);		/* bind your methods to symbols */	addbang((method)selfforce1225_bang);	addmess((method)getPos, "list", A_GIMME, 0);	addinx((method)getParam, 1);		//post("selfforce1225 loaded..");}void getPos(SelfForce1225 *x, t_symbol *msg, short argc, t_atom *argv){	if(argc > 1 && argv[0].a_type == A_LONG && argv[1].a_type == A_LONG){		x->px = argv[0].a_w.w_long;		x->py = argv[1].a_w.w_long;				if(argc > 2 && argv[2].a_type == A_LONG){			x->k = argv[2].a_w.w_long;		}	}}void getParam(SelfForce1225 *x, long k){	x->k = k;}float distance(int x1, int y1, int x2, int y2){	return (float)sqrt(pow(x2-x1, 2) + pow(y2-y1, 2));}void setOffsetVal(t_atom *ov, long n){	int i, j;	j = n / 320;	i = n - j * 320;	SETLONG(&ov[0], i);	SETLONG(&ov[1], j); }void selfforce1225_bang(SelfForce1225 *x){	int i,j;	int index = 0;	long dist, energy, value;	t_atom ov[2];		// pointer to the array of long for previous value	t_atom *pv = (t_atom *)*x->h_val;		for(j=0; j<240; j++){		for(i=0; i<320; i++, index++){			// calc distance from pixel to each person			dist = distance(i, j, x->px, x->py);						if(dist == 0){				SETLONG(&pv[index], 255);				continue;			}						// calc energy			energy = 10000.0f*x->k/dist;						// clip & invert (0 is the highest energy)			if(energy >65535) energy = 65535;			else if(energy < 0) energy = 0;			//value = 65535 - energy;			value = energy >> 8;						// output new value only when the value has changed			SETLONG(&pv[index], value);			//SETLONG(&pv[index], j*255/240);		}	}			// offset value and pixel value (0-32766, 32767-65533, 65534-76800)	setOffsetVal(ov, 0);	outlet_list(x->m_out_offset, 0L, 2, ov);	outlet_list(x->m_out, 0L, 32767, pv);		setOffsetVal(ov, 32767);	outlet_list(x->m_out_offset, 0L, 2, ov);	outlet_list(x->m_out, 0L, 32767, pv+32767);		setOffsetVal(ov, 65534);	outlet_list(x->m_out_offset, 0L, 2, ov);	outlet_list(x->m_out, 0L, 11266, pv+65534);	}//// instance creation routine//void *selfforce1225_new(){	SelfForce1225 *x;	t_atom *pv;	int i;	long pixelsize;		// create an instance	x = newobject(selfforce1225_class);		// allocate pixel memory	pixelsize = 320 * 240;	x->h_val = newhandle(sizeof(t_atom) * pixelsize); 	pv = (t_atom *)*x->h_val;	for(i=0; i<pixelsize; i++) SETLONG(&pv[i], 0);	// initialization	x->k = 50;		// crate inlet	intin(x, 1);		// create outlet	x->m_out_offset = intout(x);	x->m_out = listout(x);						return (x);							// return newly created object to caller}void selfforce1225_free(SelfForce1225 *x){	disposhandle(x->h_val);}