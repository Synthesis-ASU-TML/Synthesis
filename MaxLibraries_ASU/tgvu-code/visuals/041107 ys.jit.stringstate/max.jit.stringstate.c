/*    Copyright 2001 - Cycling '74   Joshua Kit Clayton jkc@cycling74.com*/// revised at some point by jb to include 2nd mode (necessary for particles)#include "jit.common.h"#include <math.h>typedef struct _max_jit_ys_stringstate {    t_object			ob;    void				*obex;    void 				*curvature;    void 				*heightsum;    char                                 calib;    float min_anglesum, max_anglesum;    float min_heightsum, max_heightsum;    char firstflag;} t_max_jit_ys_stringstate;typedef struct {    float x;    float y;} Vec;void *max_jit_ys_stringstate_new(t_symbol *s, long argc, t_atom *argv);void max_jit_ys_stringstate_free(t_max_jit_ys_stringstate *x);void max_jit_ys_stringstate_assist(t_max_jit_ys_stringstate *x, void *b, long m, long a, char *s);void max_jit_ys_stringstate_jit_matrix(t_max_jit_ys_stringstate *x, t_symbol *s, long argc, t_atom *argv);void max_jit_ys_stringstate_calculate_ndim(t_max_jit_ys_stringstate *x, long dimcount, long *dim, t_jit_matrix_info *in_minfo, char *bip);float getCosine(Vec *v1, Vec *v2);void *max_jit_ys_stringstate_class;		 	t_symbol *ps_done;void main(void){	    long attrflags;    void *p,*attr;	    setup(&max_jit_ys_stringstate_class, max_jit_ys_stringstate_new, (method)max_jit_ys_stringstate_free, (short)sizeof(t_max_jit_ys_stringstate), 	  0L, A_GIMME, 0);    p = max_jit_classex_setup(calcoffset(t_max_jit_ys_stringstate,obex));    //at beginning of messlist for speed    addmess((method)max_jit_ys_stringstate_jit_matrix,		"jit_matrix",		A_GIMME,0);		    attrflags = JIT_ATTR_GET_DEFER_LOW | JIT_ATTR_SET_USURP_LOW ;    attr = jit_object_new(_jit_sym_jit_attr_offset,"calib",_jit_sym_char,attrflags,			  (method)0,(method)0,calcoffset(t_max_jit_ys_stringstate,calib));    max_jit_classex_addattr(p,attr);		    max_jit_classex_standard_wrap(p,NULL,0);	    addmess((method)max_jit_ys_stringstate_assist,			"assist",			A_CANT,0);    ps_done = gensym("done");}void max_jit_ys_stringstate_jit_matrix(t_max_jit_ys_stringstate *x, t_symbol *s, long argc, t_atom *argv){    void *matrix;    long err,i,dimcount,dim[JIT_MATRIX_MAX_DIMCOUNT];    long in_savelock;    t_jit_matrix_info in_minfo;    char *in_bp;	    if (argc&&argv) {	//find matrix	matrix = jit_object_findregistered(jit_atom_getsym(argv));	if (matrix&&jit_object_method(matrix, _jit_sym_class_jit_matrix)) {	    //calculate	    in_savelock = (long) jit_object_method(matrix,_jit_sym_lock,1);	    jit_object_method(matrix,_jit_sym_getinfo,&in_minfo);	    jit_object_method(matrix,_jit_sym_getdata,&in_bp);				    if (!in_bp) { 		jit_error_sym(x,_jit_sym_err_calculate);		jit_object_method(matrix,_jit_sym_lock,in_savelock);		goto out;	    }				    //get dimensions/planecount 	    dimcount = in_minfo.dimcount;	    for (i=0;i<dimcount;i++) {		dim[i] = in_minfo.dim[i];	    }						    //calculate	    	    /*	    post("dimcount.. %d", dimcount);	    post("dim[0].. %d", dim[0]);	    post("planecount.. %d", in_minfo.planecount);	    post("dimstride[0].. %d", in_minfo.dimstride[0]);	    */	    max_jit_ys_stringstate_calculate_ndim(x, dimcount, dim, &in_minfo, in_bp);						    jit_object_method(matrix,_jit_sym_lock,in_savelock);					    max_jit_obex_dumpout(x,ps_done,0,0L);				} else {	    jit_error_sym(x,_jit_sym_err_calculate);	}    } out:    return;}float getCosine(Vec *v1, Vec *v2){    float inner_product = v1->x * v2->x + v1->y * v2->y;    float len_v1 = sqrt(v1->x * v1->x + v1->y * v1->y);    float len_v2 = sqrt(v2->x * v2->x + v2->y * v2->y);    float len_mult = len_v1 * len_v2;    float cosine_val;    if(len_mult == 0.0f) return 1.0f;    cosine_val = inner_product / len_mult;    if(cosine_val < -1.0) cosine_val = -1.0f;    if(cosine_val > 1.0) cosine_val = 1.0f;    return cosine_val;}//recursive function to handle higher dimension matrices, by processing 2D sections at a time void max_jit_ys_stringstate_calculate_ndim(t_max_jit_ys_stringstate *x, long dimcount, long *dim, t_jit_matrix_info *in_minfo, char *bip){    int i;    t_atom a_curvature;    t_atom a_heightsum;    int planecount = in_minfo->planecount;    int dimstride = in_minfo->dimstride[0];    int width = dim[0];    float angle_sum = 0.0f;    float *fp = bip;    float height_sum = fp[1];	    //Vec vec[width-1];    Vec vec[50];    //safety    if (dimcount != 1 || planecount != 2) return;    // tangent vec & height_sum    for(i=0; i<width-1; i++, fp+=2){	vec[i].x = fp[2] - fp[0];	vec[i].y = fp[3] - fp[1];	height_sum += fp[3];    }        // normalize vec    for(i=0; i<width-1; i++){	float cosine_val = getCosine(&vec[i], &vec[i+1]);	float angle = acos(cosine_val);	angle_sum += fabs(angle);    }    // if calibration is on    if(x->calib){	// only for the first time	if(x->firstflag){	    x->min_anglesum = x->max_anglesum = angle_sum;	    x->min_heightsum = x->max_heightsum = height_sum;	    x->firstflag = 0;	}		if(angle_sum < x->min_anglesum) x->min_anglesum = angle_sum;	if(angle_sum > x->max_anglesum) x->max_anglesum = angle_sum;	if(height_sum < x->min_heightsum) x->min_heightsum = height_sum;	if(height_sum > x->max_heightsum) x->max_heightsum = height_sum;	// rescale to the range 0.0-1.0	angle_sum = (x->max_anglesum == x->min_anglesum) ? 0.0f :	    (angle_sum - x->min_anglesum) / (x->max_anglesum - x->min_anglesum);	height_sum = (x->max_heightsum == x->min_heightsum) ? 0.0f :	    (height_sum - x->min_heightsum) / (x->max_heightsum - x->min_heightsum);    }    // set value for output    jit_atom_setfloat(&a_heightsum, height_sum);    jit_atom_setfloat(&a_curvature, angle_sum);    // output    outlet_float(x->heightsum, a_heightsum.a_w.w_float);    outlet_float(x->curvature, a_curvature.a_w.w_float);}void max_jit_ys_stringstate_assist(t_max_jit_ys_stringstate *x, void *b, long m, long a, char *s){    if (m == 1) { //input	sprintf(s,"(matrix) in");    } else { //output	switch (a) {	  case 0:	    sprintf(s,"curvature");	    break; 				  case 1:	    sprintf(s,"heightsum");	    break; 				}    }}	void max_jit_ys_stringstate_free(t_max_jit_ys_stringstate *x){    //only max object, no jit object    max_jit_obex_free(x);}void *max_jit_ys_stringstate_new(t_symbol *s, long argc, t_atom *argv){    t_max_jit_ys_stringstate *x;    x = (t_max_jit_ys_stringstate *)max_jit_obex_new(max_jit_ys_stringstate_class,NULL); //only max object, no jit object    max_jit_obex_dumpout_set(x,outlet_new(x,NULL));    x->heightsum = outlet_new(x,0L);    x->curvature = outlet_new(x,0L);    x->calib = 0;    x->firstflag = 1;    //no normal args, no matrices    max_jit_attr_args(x,argc,argv); //handle attribute args out:	    return (x);}