// eermDefines.h#ifndef _eermDefines_h#define _eermDefines_h#include <stdlib.h>#include <stdio.h>//====================== Debug Defines#define NDEBUG	 		// switches OFF assert() in assert.h//#undef NDEBUG#define MDebug  		// switches on other eerm debug stuff//#define MemDebug	// switch for memory allocation debugging.  										// uses globals, so only one instance of eerm should be created if this is on.//#define MErrors 		// switches on errors (not recommended to turn off)#define MErrorsDebug	// switches on errors with DebugStr #define MAssertions 	// switches on eerm assertion macro (calling assert() and error()) #define MTraces 				// switches on eerm traces#define MTraceEvolve	// switches on trace of deltas#define MTraceForce		//#define MTraceCalls 	// switches on eerm traces of function calls//----------------------- ANSI assertions#include <assert.h>//----------------------- Globalsint iii;#ifdef MemDebug	long membytes=0;	long memeermmaxlabels=0;#endif//----------------------- Types#define TBool int//----------------------- Constants#ifndef RAND_MAX#define RAND_MAX 32767  // already defined in ANSI implementations#endif#define KEpsilon	0.000001  // huh?#define KPi				3.1415926535897932384626433832797#define KMinDt		1.0//----------------------- Numerical Macros#define MMax(a,b) 	(((a) > (b)) ? (a) : (b))#define MMin(a,b)    (((a) < (b)) ? (a) : (b))#define MAbs(a) 		(((a) < 0) ? (-a) : (a))#define MFloor(a,f)  	(((a) == 0.0) ? (f) : (a))//----------------------- Memory Macros#ifdef MemDebug	#define getmem(size) \		(((size)<32767)?getbytes(size):NewPtr(size)); \		membytes = membytes + size;	#define freemem(var,size) \		if ((size)<32767){freebytes((char *)(var),(short)(size));} \		else{DisposePtr((char *)var);} \			membytes = membytes - size;#else	#define getmem(size) \		(((size)<32767)?getbytes(size):NewPtr(size)); 	#define freemem(var,size) \		if ((size)<32767){freebytes((char *)(var),(short)(size));} \		else{DisposePtr((char *)var);} #endif#define initvec(vec,val,size) \	for (iii=0; iii<size; iii++) {vec[iii]=val;} #define copyvec(vec1,vec2,size) \	for (iii=0; iii<size; iii++) {vec2[iii] = vec1[iii];}		//======================== Debugging//----------------------- Errors#ifdef MErrors		#define MError(expression, msg) {if (!(expression)) {error(msg);}}	#define MErrorVoid(expression,msg) {if (!(expression)) {error(msg); return;}}	#define MErrorPtr(expression,msg) {if (!(expression)) {error(msg); return NULL;}}	#define MErrorInt(expression,msg) {if (!(expression)) {error(msg); return -1;}}	#define MErrorFloat(expression,msg) {if (!(expression)) {error(msg); return -1.0;}}#else 	#ifdef MErrorsDebug			#define MError(expression, msg) {if (!(expression)) {error(msg);DebugStr((const unsigned char *)msg);}}		#define MErrorVoid(expression,msg) {if (!(expression)) {error(msg); DebugStr((const unsigned char *)msg);return;}}		#define MErrorPtr(expression,msg) {if (!(expression)) {error(msg); DebugStr((const unsigned char *)msg); return NULL;}}		#define MErrorInt(expression,msg) {if (!(expression)) {error(msg); DebugStr((const unsigned char *)msg); return -1;}}		#define MErrorFloat(expression,msg) {if (!(expression)) {error(msg); DebugStr((const unsigned char *)msg); return -1.0;}}	#else		#define MError(expression, msg) {}		#define MErrorVoid(expression,msg) {}		#define MErrorPtr(expression,msg) {}		#define MErrorInt(expression,msg) {}		#define MErrorFloat(expression,msg) {}	#endif#endif//----------------------- Assertions#ifdef MAssertions		#define MAssert(expression,msg) {assert(expression); if (!(expression)) {DebugStr((const unsigned char *)msg); error(msg);}}	#define MAssertVoid(expression,msg) {assert(expression); if (!(expression)) {DebugStr((const unsigned char *)msg); error(msg); return;}}	#define MAssertPtr(expression,msg) {assert(expression); if (!(expression)) {DebugStr((const unsigned char *)msg); error(msg); NULL;}}	#define MAssertInt(expression,msg) {assert(expression); if (!(expression)) {DebugStr((const unsigned char *)msg); error(msg); return -1;}}	#define MAssertFloat(expression,msg) {assert(expression); if (!(expression)) {DebugStr((const unsigned char *)msg); error(msg); return -1.0;}}	#define MInvalid(msg) {DebugStr((const unsigned char *)msg); error(msg);}#else	#define MAssert(expression, msg) {}	#define MAssertVoid(expression,msg) {}	#define MAssertPtr(expression,msg) {}	#define MAssertInt(expression,msg) {}	#define MAssertFloat(expression,msg) {}	#define MInvalid(msg) {}#endif#ifdef MemDebug	#define MMemEntry int memcount = membytes;	#define MMemExit {if (memcount != membytes) {error("eerm:\tmemory leak here."); post("eerm:\t%d -> %d bytes",memcount,membytes); DebugStr((const unsigned char *)("memory leak here"));}}	#define MPostMemChange {post("Mem usage changed %d bytes", (memcount - membytes));}	#define MMemChkStart int memcount = membytes;	#define MMemChkExit(gmem){gmem += membytes - memcount;}#else	#define MMemEntry	#define MMemExit	#define MPostMemChange 	#define MMemChkStart	#define MMemChkExit(gmem)#endif//----------------------- Traces#ifdef MTraces#define MTrace(msg) {post(msg);}#define MTrace1(msg,val1) {post(msg,val1);}#define MTrace2(msg,val1,val2) {post(msg,val1,val2);}#define MTrace3(msg,val1,val2,val3) {post(msg,val1,val2,val3);}#define MTrace4(msg,val1,val2,val3,val4) {post(msg,val1,val2,val3,val4);}#define MTrace5(msg,val1,val2,val3,val4,val5) {post(msg,val1,val2,val3,val4,val5);}#else#define MTrace(msg) {}#define MTrace1(msg,val1) {}#define MTrace2(msg,val1,val2) {}#define MTrace3(msg,val1,val2,val3) {}#define MTrace4(msg,val1,val2,val3,val4) {}#define MTrace5(msg,val1,val2,val3,val4,val5) {}#endif#ifdef MTraceCalls#define MTraceCall(msg) {post(msg);}#else#define MTraceCall(msg) {}#endif#define unused(var) {iii = (int)&var;}//======================= Functions//----------------------- resizememvoid *resizemem(void *var, long oldsize, long newsize);//----------------------- resizememvoid *resizemem(void *var, long oldsize, long newsize){	MAssertPtr(var != NULL, "null ptr");	MAssertPtr((oldsize > 0) && (newsize > 0), "");	MTrace2("eerm:\resizemem %d -> %d",oldsize,newsize);		//--Deallocate:	if ((oldsize) < 32767) 										{ 																		freebytes((char *)(var),(short)(oldsize)); 		} 												else 											{ 													DisposePtr((char *)var); 			} 												#ifdef MemDebug		membytes = membytes - oldsize; 		#endif		//--Allocate:		#ifdef MemDebug		membytes = membytes + newsize;	#endif	if ((newsize)<32767) 					{ 													return getbytes(newsize);	} 												else 											{ 													return NewPtr(newsize); 		} 											}