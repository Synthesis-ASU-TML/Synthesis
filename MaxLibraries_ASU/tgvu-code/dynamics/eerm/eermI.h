// eermI.h//   implementation file for the eerm,  //   a particle/token based pattern model//==========// Includes//==========#include "GraphModelUtilI.h"#include "eerm.h"//========// Macros//========#ifdef MDebug#define MVectorIsPositive(w,n) VectorIsPositive(w,n)#define MWeightIsValid(w,n) WeightIsValid(w,n)#define MVectorIsTangent(w,n) VectorIsTangent(w,n)#define MVectorIsConvex(w,n) VectorIsConvex(w,n)#define MNodeIsValid(n) NodeIsValid(n)#define MNodeListIsValid(n,Nn) NodeListIsValid(n,Nn)#define MTokenIsValid(t) TokenIsValid(t)#define MSimplexIsValid(s) SimplexIsValid(s)#define MSimplexIsValidWithoutNodes(s) SimplexIsValidWithoutNodes(s)#define MFeatureIsValid(f) FeatureIsValid(f)#define MEermIsValid(e) EermIsValid(e)#define MTokenTraceCoord(t) TokenTraceCoord(t)#else#define MVectorIsPositive(w,n) #define MWeightIsValid(w,n) #define MVectorIsTangent(w,n) #define MNodeIsValid(n) #define MNodeListIsValid(n,Nn) #define MTokenIsValid(t) #define MSimplexIsValid(s) #define MSimplexIsValidWithoutNodes(s)#define MFeatureIsValid(f) #define MEermIsValid(e) #define MTokenTraceCoord(t)#endif//=================// Implementations//=================//====================== Validity//---------------------- VectorIsPositivevoid VectorIsPositive(float *w, int n){	int i;	MTraceCall("eerm:\tVectorIsPositive..");		if (n == 0) 	{		MTraceCall("eerm:\tVectorIsPositive finished.");		return;	}	MAssertVoid(w != NULL, "VectorIsPositive: Invalid weight ptr");	for (i = 0; i < n; i++)		MAssertVoid(w[i] > 0.0, "VectorIsPositive: Invalid weight");	MTraceCall("eerm:\tVectorIsPositive finished.");	}//---------------------- VectorIsNonNegativevoid VectorIsNonNegative(float *w, int n){	int i;	MTraceCall("eerm:\tVectorIsNonnegative..");		if (n == 0) 	{		MTraceCall("eerm:\tVectorIsNonnegative finished.");		return;	}	MAssertVoid(w != NULL, "VectorIsNonNegative: Invalid weight ptr");	for (i = 0; i < n; i++)		MAssertVoid(w[i] >= 0.0, "VectorIsNonNegative: Invalid weight");	MTraceCall("eerm:\tVectorIsNonnegative finished.");	}//---------------------- WeightIsValid// Todo : delete use of this function.void WeightIsValid(float *w, int n){	VectorIsConvex(w,n);}//---------------------- VectorIsTangentvoid VectorIsTangent(float *w, int n)// w is tangent to the prototype n-simplex if components sum to zero{	int i;	double sum = 0.0;		MTraceCall("eerm:\tVectorIsTangent..");	if (n == 0) 	{		MTraceCall("eerm:\tVectorIsTangent finished.");		return;	}	MAssertVoid(w != NULL, "VectorIsTangent: Invalid vec ptr");	for (i = 0; i < n; i++)	{		sum = sum + (double)w[i];	}	MAssertVoid(((float)sum) <= (KEpsilon), "VectorIsTangent: nonzero sum");	MTraceCall("eerm:\tVectorIsTangent finished.");}//---------------------- VectorIsConvexvoid VectorIsConvex(float *w, int n){	int i;	double sum = 0.0;		MTraceCall("eerm:\tVectorIsConvex..");	if (n == 0) 	{		MTraceCall("eerm:\tVectorIsConvex finished.");		return;	}	MAssertVoid(w != NULL, "VectorIsConvex: Invalid weight ptr");	for (i = 0; i < n; i++)	{		MAssertVoid(w[i] >= 0.0, "VectorIsConvex: negative weight.");		sum = sum + (double)w[i];	}	MAssertVoid( (((float)sum - 1.0f) <= KEpsilon) , "VectorIsConvex: nonconvex sum");	MTraceCall("eerm:\tVectorIsConvex finished.");}//---------------------- NodeIsValidvoid NodeIsValid(Node *n){	MTraceCall("eerm:\tNodeIsValid..");	MAssertVoid(n != NULL, "Invalid node: null ptr");	MAssertVoid(n->index >= -1, "Invalid node: bad index");	MAssertVoid(n->Nf >= 0, "Invalid node: bad Nf");	MWeightIsValid(n->tp, n->nstates);	MAssertVoid(n->mean != NULL, "Invalid node: bad meanptr");	MAssertVoid(n->ivar != NULL, "Invalid node: bad varptr");	MAssertVoid(n->nstates > -1, "Invalid node: bad nstates");		MTraceCall("eerm:\tNodeIsValid finished.");}//---------------------- NodeListIsValidvoid NodeListIsValid(Node **n, int Nn){	int i;	MTraceCall("eerm:\tNodeListIsValid..");	MAssertVoid(n != NULL, "NodeListIsValid: null nodelist ptr");	MAssertVoid(Nn > 0, "NodeListIsValid: NodeList is empty.");	MNodeIsValid(n[0]);	for (i = 1; i < Nn; i++)	{		MAssertVoid(n[i-1]->index <= n[i]->index, "NodeListIsValid: bad ordering");		MNodeIsValid(n[i]);	}			MTraceCall("eerm:\tNodeListIsValid finished.");}//---------------------- SimplexIsValidvoid SimplexIsValid(Simplex *s){	int i;	MTraceCall("eerm:\tSimplexIsValid..");	MAssertVoid(s != NULL, "Invalid simplex: null ptr");	MAssertVoid(s->index >= -1, "Invalid simplex: bad index");	MAssertVoid(s->Nn >= 1, "Invalid simplex: bad nn");	for (i = 0; i < s->Nn; i++)	{		NodeIsValid(s->nodes[i]);	}	MWeightIsValid(s->tp, s->NsMax);	MTraceCall("eerm:\tSimplexIsValid finished.");}//---------------------- SimplexIsValidWithoutNodesvoid SimplexIsValidWithoutNodes(Simplex *s){	int i;	MTraceCall("eerm:\tSimplexIsValid..");	MAssertVoid(s != NULL, "Invalid simplex: null ptr");	MAssertVoid(s->index >= -1, "Invalid simplex: bad index");	MAssertVoid(s->Nn >= 1, "Invalid simplex: bad nn");	for (i = 0; i < s->Nn; i++)	{		NodeIsValid(s->nodes[i]);	}	MWeightIsValid(s->tp, s->NsMax);	MTraceCall("eerm:\tSimplexIsValid finished.");}//---------------------- FeatureIsValidvoid FeatureIsValid(Feature *f){	MTraceCall("eerm:\tFeatureIsValid..");	MAssertVoid(f != NULL, "Invalid Feature: bad fptr");	MAssertVoid(f->Nf >= 0, "Invalid Feature: bad Nf");	VectorIsNonNegative(f->weights, f->Nf);	MAssertVoid(f->out != NULL, "Invalid Feature: bad f->out ptr");	MAssertVoid(f->slew >= 0.0, "Invalid feature bad slew");	MTraceCall("eerm:\tFeatureIsValid finished.");}//---------------------- TokenIsValidvoid TokenIsValid(Token *t){	MTraceCall("eerm:\tTokenIsValid..");	MAssertVoid(t != NULL, "Invalid token: bad tptr");	MAssertVoid((t->index >= -1), "Invalid token: bad index");	MFeatureIsValid(t->f);	MSimplexIsValid(t->s);	MAssertVoid(t->Nf >= 0, "Invalid token: bad Nf");	MAssertVoid(t->vcoord != NULL, "Invalid token: bad vcoord ptr");	MVectorIsConvex(t->coord, t->Nn);	MAssertVoid(t->obs != NULL, "Invalid token: bad obs ptr");	MAssertVoid(t->Nn >= 1, "Invalid token: bad Nn");	MAssertVoid(t->mass > 0.0, "Invalid token: bad mass");	MAssertVoid(t->expscale >= 0.0, "Invalid token: bad expscale");	MAssertVoid((t->stulle == 0) || (t->stulle ==1), "Invalid token: bad stulle flag");	MTraceCall("eerm:\tTokenIsValid finished.");}//---------------------- EermIsValidvoid EermIsValid(Eerm *e){	int i;	MTraceCall("eerm:\tEermIsValid..");		MAssertVoid(e != NULL, "Invalid Eerm: bad ptr");	MAssertVoid((e->NsMax > 0) && (e->NtMax > 0), "Invalid eerm: bad nsmax or ntmax");	MAssertVoid(e->dt > 0.0, "Invalid eerm: bad dt");	MAssertVoid(e->temp >= 0.0, "Invalid eerm: bad temp");	MAssertVoid(e->sensorforce >= 0, "Invalid eerm: bad sensorforce");	MAssertVoid((e->NnMax > 0) && (e->Nn <= e->NnMax), "Invalid eerm: bad NnMax");		MSimplexIsValid(e->entrysimplex);	MSimplexIsValid(e->tmpsmp);	MNodeIsValid(e->tmpnode);	MTokenIsValid(e->tmptoken);	MFeatureIsValid(e->protof);	MNodeListIsValid(e->nodes, e->Nn);	for(i = 0; i < e->Nt; i++)	{		MTokenIsValid(e->tokens[i]);	}	for(i = 0; i < e->Ns; i++)	{		MSimplexIsValid(e->simplices[i]);	}	MTraceCall("eerm:\tEermIsValid finished.");}//---------------------- NodeIndexListIsValidTBool NodeIndexListIsValid(Eerm *e, int *n, int Nn){	int i;	MErrorInt((Nn <= e->Nn) && (Nn >= 1), "Wrong number nodes");	MErrorInt((n != NULL), "Null ptr received");	for (i = 0; i < Nn; i++)	{		MErrorInt(n[i] < e->Nn, "invalid node index");		MErrorInt(n[i] >= 0, "invalid node index");	}	return 1;}//---------------------- SortedNodeIndexListIsValidTBool SortedNodeIndexListIsValid(Eerm *e, int *n, int Nn){	int i;	MErrorInt((Nn <= e->Nn) && (Nn >= 1), "Wrong number nodes");	MErrorInt((n != NULL), "Null ptr received");	if (Nn == 1) return 1;		for (i = 0; i < Nn - 1; i++)	{		MErrorInt(n[i] < e->Nn, "invalid node index");		MErrorInt(n[i] >= 0, "invalid node index");		MErrorInt(n[i] < n[i+1], "bad node index sort order.");	}	MErrorInt(n[i] < e->Nn, "invalid node index");	MErrorInt(n[i] >= 0, "invalid node index");		return 1;}//====================== New / Free//---------------------- FeatureNewFeature  *FeatureNew(int Nf, float slew){	Feature *f;		MMemChkStart;	MTraceCall("eerm:\tFeatureNew..");	MAssertPtr(Nf >= 1, "Nf < 1");	MAssertPtr(slew >= 0.0, "slew < 0");		// Make new struct	f = (Feature *)getmem(sizeof(struct feature));			MAssertPtr(f != NULL, "didn't get mem");		// Set state	f->Nf = Nf;	f->slew = slew;		// Allocate arrays	f->weights = (float *)getmem(Nf * sizeof(float));	MAssertPtr(f->weights != NULL, "didn't get mem");	f->out = (float *)getmem(Nf * sizeof(float));	MAssertPtr(f->out != NULL, "didn't get mem");	// Init arrays	initvec(f->out, 0.0, Nf);	initvec(f->weights, 1.0, Nf);	MFeatureIsValid(f);	MTraceCall("eerm:\tFeatureNew finished.");	#ifdef MemDebug	MMemChkExit(gMemFeature);	#endif	return f;}//---------------------- FeatureFreevoid 	FeatureFree(Feature *f){	MMemChkStart;	MTraceCall("eerm:\tFeatureFree..");	MFeatureIsValid(f);	freemem(f->out, f->Nf * sizeof(float));	freemem(f->weights, f->Nf * sizeof(float));	freemem(f, sizeof(struct feature));	f = NULL;		MTraceCall("eerm:\tFeatureFree finished.");	#ifdef MemDebug	MMemChkExit(gMemFeature);	#endif	return;}//---------------------- TokenNewToken	*TokenNew(int index, Simplex *s, int Nf, float slew, int NnMax){	Token *t;	MMemChkStart;	MTraceCall("eerm:\tTokenNew..");	MAssertPtr(Nf >= 1, "Nf < 1");	MSimplexIsValid(s);	// Make new struct	t = (Token *)getmem(sizeof(struct token));	MAssertPtr(t != NULL, "didn't get mem.");	// Set simplex	t->s = s;	// Set state	t->index = index;	t->Nn = s->Nn;	t->Nf = Nf;	t->mass = KMassDefault;	t->expscale = KExpScaleDefault;	t->damping = KDampingDefault;	t->tokencoupling = KTokenCouplingDefault;	t->stulle = 0;	// Allocate feature	t->f = FeatureNew(Nf, slew);	MAssertPtr(t->f != NULL, "invalid fptr");		// Allocate arrays		// [Todo] : think about how to allocate so that we don't have to resize.	t->coord = (float *)getmem(NnMax * sizeof(float));	MAssertPtr(t->coord != NULL, "didn't get mem");	t->vcoord = (float *)getmem(NnMax * sizeof(float));	MAssertPtr(t->vcoord != NULL, "didn't get mem");	t->obs = (float *)getmem(Nf * sizeof(float));	MAssertPtr(t->obs != NULL, "didn't get mem");	// Init arrays	initvec(t->obs, 0.0, Nf);	initvec(t->coord, 0.0, NnMax);	initvec(t->vcoord, 0.0, NnMax);	initvec(t->coord, 1.0 / (float)s->Nn, s->Nn);	MTokenIsValid(t);	MTraceCall("eerm:\tTokenNew finished.");	#ifdef MemDebug	MMemChkExit(gMemToken);	#endif		return t;}//---------------------- StulleTokenNewToken	*StulleTokenNew(int index, Simplex *s, int Nf, float slew, int NnMax){	Token *t;	MTraceCall("eerm:\tStulleTokenNew..");	t = TokenNew(index, s, Nf, slew, NnMax);	t->stulle = 1;	initvec(t->f->weights, 0.0, t->Nf);	MTraceCall("eerm:\tStulleTokenNew finished.");	return t;}//---------------------- TokenFreevoid	TokenFree(Token *t, int NnMax){	MMemChkStart;	MTokenIsValid(t);	MTraceCall("eerm:\tTokenFree..");	freemem(t->coord, NnMax * sizeof(float));	freemem(t->vcoord, NnMax * sizeof(float));	freemem(t->obs, t->Nf * sizeof(float));	FeatureFree(t->f);	freemem(t, sizeof(struct token));			t = NULL;	MTraceCall("eerm:\tTokenFree finished.");	#ifdef MemDebug	MMemChkExit(gMemToken);	#endif	return;}//---------------------- NodeNewNode 	*NodeNew(int index, int Nf, int nstates){	Node *n;	MMemChkStart;	MTraceCall("eerm:\tNodeNew..");	// Check args	MAssertPtr(nstates >= 1, "received bad nstates");	MAssertPtr(Nf >= 1, "bad Nf");		// Make new struct	n = (Node *)getmem(sizeof(struct node));	// Set state	n->index = index;	n->Nf = Nf;	n->nstates = nstates;	n->potential = KNodePotentialDefault;	// Allocate arrays		n->tp = (float *)getmem(nstates * sizeof(float));	MAssertPtr(n->tp != NULL, "didn't get mem");	n->mean = (float *)getmem(Nf * sizeof(float));	MAssertPtr(n->mean != NULL, "didn't get mem");	n->ivar = (float *)getmem(Nf * sizeof(float));	MAssertPtr(n->ivar != NULL, "didn't get mem");	// Init arrays	initvec(n->tp, 1.0 / nstates, nstates);	initvec(n->mean, 0.0, Nf);	initvec(n->ivar, KInvVarianceDefault, Nf);	MNodeIsValid(n);		#ifdef MemDebug	MMemChkExit(gMemNode);	#endif	MTraceCall("eerm:\tNodeNew finished.");	return n;}//---------------------- NodeFreevoid 	NodeFree(Node *n){	MMemChkStart;	MTraceCall("eerm:\tNodeFree..");	MNodeIsValid(n);	freemem(n->tp, n->nstates * sizeof(float));	freemem(n->mean, n->Nf * sizeof(float));	freemem(n->ivar, n->Nf * sizeof(float));	freemem(n, sizeof(struct node));	n = NULL;		#ifdef MemDebug	MMemChkExit(gMemNode);	#endif	MTraceCall("eerm:\tNodeFree finished.");	return;}//---------------------- SimplexNewSimplex	*SimplexNew(int index, int Ns, int NsMax, int Nn, Node **nodes){	Simplex *s;	MMemChkStart;	MTraceCall("eerm:\tSimplexNew..");	// Check args	MAssertPtr(NsMax >= 1, "Bad num simplices");	MAssertPtr(Nn >= 1, "Null ptr received");	NodeListIsValid(nodes, Nn);		// Make new struct	s = (Simplex *)getmem(sizeof(struct simplex));	MAssertPtr(s != NULL, "Didn't get mem.");	// Set state	s->index = index;	s->Nn = Nn;	s->NsMax = NsMax;		// Allocate arrays	s->tp = (float *)getmem(NsMax * sizeof(float));	MAssertPtr(s->tp != NULL, "didn't get mem");	s->nodes = (Node **)getmem(Nn * sizeof(Node *));	MAssertPtr(s->nodes != NULL, "didn't get mem");	// Init arrays	copyvec(nodes, s->nodes, s->Nn);	initvec(s->tp, 0.0, s->NsMax); // Disconnected by default.	// This is not very nice, but shouldn't matter:	if (s->index == -1)	{		s->tp[0] = 1.0;	}	else	{		s->tp[s->index] = 1.0;	}	MSimplexIsValid(s);	#ifdef MemDebug	MMemChkExit(gMemSimplex); 	#endif	MTraceCall("eerm:\tSimplexNew finished.");		return s;}//---------------------- SimplexFreevoid 	SimplexFree(Simplex *s){	MMemChkStart;	MTraceCall("eerm:\tSimplexFree..");	MSimplexIsValidWithoutNodes(s);	freemem(s->tp, s->NsMax * sizeof(float));	freemem(s->nodes, s->Nn * sizeof(Node *));		freemem(s,sizeof(struct simplex));		s = NULL;	MTraceCall("eerm:\tSimplexFree finished.");	#ifdef MemDebug	MMemChkExit(gMemSimplex);	#endif	return;}	//---------------------- EermNewEerm	*EermNew(int Nn, int NsMax, int NtMax, int Nf, float dt){	Eerm *e;	int i;	MMemChkStart;	MTraceCall("eerm:\tEermNew..");	// Check args	MAssertPtr(Nn >= 1, "invalid Nn");	MAssertPtr(NsMax >= 1, "invalid NsMax");	MAssertPtr(NtMax >= 1, "invalid NtMax");	MAssertPtr(Nf >= 1, "invalid Nf");	MAssertPtr(dt > 0.0f, "invalid dt");	// Make new struct	e = (Eerm *)getmem(sizeof(struct eerm));	MAssertPtr(e != NULL, "failed to get mem");		// Set State		// Todo : clear this up.	//  either eliminate Nn, or 	//  whatever.	e->Nn = Nn;	e->NnMax = Nn;	e->Ns = 0;	// we dont count temp simplices here.	e->NsMax = NsMax;	e->Nt = 0;	e->NtMax = NtMax;	e->dt = dt;	e->temp = KTempDefault;	e->sensorforce = KSensorForceDefault;	// Create temp data	e->tmpnode = NodeNew(-1, Nf, 1);	e->tmpsmp = SimplexNew(-1, 1, 1, 1, &e->tmpnode);	e->tmptoken = TokenNew(-1, e->tmpsmp, Nf, KSlewDefault, e->NnMax);	e->protof = FeatureNew(Nf, KSlewDefault);		e->entrysimplex = e->tmpsmp;	// Allocate pointers to data	e->nodes = (Node **)getmem(Nn * sizeof(Node  * ));	MAssertPtr(e->nodes != NULL, "didn't get mem");	e->simplices = (Simplex **)getmem(NsMax * sizeof(Simplex  * ));	MAssertPtr(e->simplices != NULL, "didn't get mem");	e->tokens = (Token **)getmem(NtMax * sizeof(Token  * ));	MAssertPtr(e->tokens != NULL, "didn't get mem");	// Initialize data pointers	initvec(e->nodes, NULL, Nn);	initvec(e->simplices, NULL, NsMax);	initvec(e->tokens, NULL, NtMax);	// Allocate nodes	for (i=0; i<e->Nn; i++)	{		e->nodes[i] = NodeNew(i, Nf, Nn);		if (e->nodes[i] == NULL) 		{			MTraceCall("eerm:\tEermNew finished.");			return NULL;		}	}	MEermIsValid(e);			#ifdef MemDebug	MMemChkExit(gMemEerm);	#endif	MTraceCall("eerm:\tEermNew finished.");	return e;} //---------------------- EermFreevoid 	EermFree(Eerm *e){	int i;	int NnMax;			MMemChkStart;	MTraceCall("eerm:\tEermFree..");	MEermIsValid(e);		NnMax = e->NnMax;		// Free nodes	for (i = 0; i < e->Nn; i++)	{		NodeFree(e->nodes[i]);	}		// Free tokens	if (e->Nt > 0)	{		for (i = 0; i< e->Nt; i++) 		{			TokenFree(e->tokens[i], NnMax);		}	}	// Free simplices	if (e->Ns > 0)	{		for (i = 0; i < e->Ns; i++)			{			SimplexFree(e->simplices[i]);		}	}		// Free temp data	TokenFree(e->tmptoken, NnMax);	FeatureFree(e->protof);	NodeFree(e->tmpnode);	SimplexFree(e->tmpsmp);  	// Free pointers to data	freemem(e->tokens, e->NtMax * sizeof(Token *));	freemem(e->simplices, e->NsMax * sizeof(Simplex *));	freemem(e->nodes, e->Nn * sizeof(Node *));	// Free struct	freemem(e, sizeof(struct eerm));	e = NULL;	#ifdef MemDebug	MMemChkExit(gMemEerm);	#endif		MTraceCall("eerm:\tEermFree finished.");	return;}//====================== Add Tokens / Nodes//---------------------- EermTokenAddint EermTokenAdd(Eerm *e, Token *t){	return EermTokenAddAt(e, t, e->entrysimplex->index);}//---------------------- EermTokenAddAtint 	EermTokenAddAt(Eerm *e, Token *t, int i){	Simplex *newsimplex;	MMemEntry;		MTraceCall("eerm:\tEermTokenAddAt..");	MTokenIsValid(t);	MEermIsValid(e);	MAssertInt((i >= -1) && (i < e->Ns), "invalid index");  // note: -1 is the temp simplex	MAssertInt(t->Nf == e->tmptoken->Nf, "Incompatible feature sizes");	MAssertInt(e->Nt <= e->NtMax - 1, "no more tokens");	if (i != -1)	{		newsimplex = e->simplices[i];	}	else	{		newsimplex = e->tmpsmp;	}	// Todo : Check that the token is not already in the eerm.		// Add the token	e->Nt = e->Nt + 1;	e->tokens[e->Nt - 1] = t;	t->index = e->Nt - 1;	copyvec(e->tmptoken->f->weights, t->f->weights, t->Nf);	initvec(t->coord, 0.0, e->Nn);	initvec(t->vcoord, 0.0, e->Nn);	// assign it to the requested simplex	t->s = newsimplex;	initvec(t->coord, 1.0 / (float)newsimplex->Nn, newsimplex->Nn);	MMemExit;		MTraceCall("eerm:\tEermTokenAddAt finished.");	return(t->index);}//---------------------- EermNodeAddint		EermNodeAdd(Eerm *e, Node *n){	MMemEntry;	  	MTraceCall("eerm:\tEermNodeAdd..");	MNodeIsValid(n);	MEermIsValid(e);	MAssertInt(n->Nf == e->tmpnode->Nf, "Incompatible Nf");	MAssertInt(e->Nn <= e->NnMax - 1, "Max nodes reached");		// Add the node	e->Nn = e->Nn + 1;	e->nodes[e->Nn] = n;	n->index = e->Nn;			MMemExit;		MTraceCall("eerm:\tEermNodeAdd finished.");	return(e->Nn);}//---------------------- EermSimplexAddint 	EermSimplexAdd(Eerm *e, int Nn, int *n){	int i;	Node **TempNodeList;	MTraceCall("eerm:\tEermSimplexAdd..");	MEermIsValid(e);	MAssertInt(e->Ns < e->NsMax, "eerm is full");	MErrorInt(NodeIndexListIsValid(e,n,Nn), "Bad node index list.");	// Todo : Sort the list of node indices:	// Need to fix this function..	isort(Nn,n);	MAssertInt(SortedNodeIndexListIsValid(e,n,Nn), "Bad (sorted) node index list.");	// Create the temporary list of nodeptrs.	TempNodeList = (Node **)getmem(Nn * sizeof(struct Node *));	// Copy the indexed nodes to the temporary nodelist	for (i = 0; i < Nn; i++)	{		TempNodeList[i] = e->nodes[n[i]];	}		MNodeListIsValid(TempNodeList, Nn);	// Does simplex already exist in Eerm?	i = EermNodeListFind(e, TempNodeList, Nn);	if (i > 0) 	{		MTraceCall("eerm:\tEermSimplexAdd finished.");		return i;	}			// Create the simplex and point the last element of e->simplices to it.	e->simplices[e->Ns] = SimplexNew(e->Ns, e->Ns, e->NsMax, Nn, TempNodeList);			// Increment number of simplices.	e->Ns = e->Ns + 1;	freemem(TempNodeList, Nn * sizeof(struct Node *));		MEermIsValid(e);	MTraceCall("eerm:\tEermSimplexAdd finished.");	return (e->Ns - 1);}//---------------------- EermMoreTokensvoid	EermMoreTokens(Eerm *e, int NtMax){	Token **TempTokenList;		MTraceCall("eerm:\tEermMoreTokens..");	MEermIsValid(e);	MAssertVoid(NtMax > 0, "Bad arg NtMax");	if (NtMax < e->NtMax) 	{		MTraceCall("eerm:\tEermMoreTokens finished.");		return;	}	// Make a temporary copy of the token pointer list:	TempTokenList = (Token **)getmem(e->Nt * sizeof(Token *));		// Copy the token pointer list to the temp list:	copyvec(e->tokens, TempTokenList, e->Nt);	// Resize the struct member:	e->tokens = (Token **)resizemem(e->tokens, 		e->NtMax * sizeof(Token *), NtMax * sizeof(Token *));	// Initialize the token list.	initvec(e->tokens, NULL, NtMax);		// Copy the temp list to the token pointer list:	copyvec(TempTokenList, e->tokens, e->Nt);		// Free the temporary list	freemem(TempTokenList, e->Nt * sizeof(Token *));	MEermIsValid(e);	MTraceCall("eerm:\tEermMoreTokens finished.");}//---------------------- EermNodeListFindint EermNodeListFind(Eerm *e, Node **NodeList, int Nn){	int i;	MTraceCall("eerm:\tEermNodeListFind..");	MEermIsValid(e);	MNodeListIsValid(NodeList, Nn);	MAssertInt((Nn <= e->Nn) && (Nn >= 1), "Wrong number nodes");	for (i = 0; i < e->Ns; i++)	{		if (NodeListCompare(e->simplices[i]->nodes, e->simplices[i]->Nn,NodeList, Nn))		{			MTraceCall("eerm:\tEermNodeListFind finished.");			return i;		}	}	MTraceCall("eerm:\tEermNodeListFind finished.");	return -1;}//---------------------- EermTokenDeletevoid	EermTokenDelete(Eerm *e, int i){	int num;	MMemEntry;	MTraceCall("eerm:\tEermTokenDelete..");	MEermIsValid(e);	MAssertVoid(i >= 0, "invalid token index.");	MTokenIsValid(e->tokens[i]);		TokenFree(e->tokens[i], e->NnMax);	num = CompactPtrArray((void **)e->tokens, e->NtMax);	// Todo: Need a version of this which updates the Token Indices.	// Todo: Need to figure out how to make this into a consistent interface,	//       in which the client maintains its own index of the Tokens.	//       -- Perhaps we can return a vector of ints.		e->Nt = e->Nt - 1;	MAssertVoid(e->Nt == num, "Token list size after compacting is not correct.");	MMemExit;	MTraceCall("eerm:\tEermTokenDelete finished.");	return;}//---------------------- EermSimplexDeletevoid EermSimplexDelete(Eerm *e, int i){	MMemEntry;	MTraceCall("eerm:\tEermSimplexDelete..");	MEermIsValid(e);	MAssertVoid((i > 0) && (i < e->Ns), "index out of range");		MSimplexIsValid(e->simplices[i]);		EermSimplexZeroTp(e, i);	SimplexFree(e->simplices[i]);	//e->Ns = e->Ns - 1;  	// [Todo] See comments above.		MMemExit;	MTraceCall("eerm:\tEermSimplexDelete finished.");	return;}//---------------------- EermSimplexZeroTpvoid EermSimplexZeroTp(Eerm *e, int i){	int j;	MMemEntry;	MTraceCall("eerm:\tEermSimplexZeroTp..");	MEermIsValid(e);	MAssertVoid((i > 0) && (i < e->Ns), "index out of range");	for (j=0; j<e->Ns; j++)	{		e->simplices[j]->tp[i] = 0.0;	}	MMemExit;	MTraceCall("eerm:\tEermSimplexZeroTp finished.");}//---------------------- EermSetEntryvoid	EermSetEntry(Eerm *e, int i){	MMemEntry;		MTraceCall("eerm:\tEermSetEntry..");	MAssertVoid((e != NULL), "null ptr received");	MAssertVoid(i >= -1, "Invalid entry point");	e->entrysimplex = e->simplices[i];	MMemExit;		MTraceCall("eerm:\tEermSetEntry finished.");}//====================== Set Parameters//---------------------- EermSetDtvoid	EermSetDt(Eerm *e, float Dt){	MMemEntry;	MTraceCall("eerm:\tEermSetDt..");	MAssertVoid(Dt > 0.0, "MInvalid dt");	e->dt = Dt;		MMemExit;	MTraceCall("eerm:\tEermSetDt finished.");}//---------------------- EermSetWeights// set all weights to the desired vals.void	EermSetWeights(Eerm *e, float *w, int n){	int i;	MMemEntry;		MTraceCall("eerm:\tEermSetWeights..");	MWeightIsValid(w, n);	FeatureSetWeights(e->tmptoken->f, w, n);	FeatureSetWeights(e->protof, w, n);	for (i = 0; i < e->Nt; i++)	{		FeatureSetWeights(e->tokens[i]->f, w, n);		}	MMemExit;	MTraceCall("eerm:\tEermSetWeights finished.");}//---------------------- EermSetSlew// set all slews to the desired vals.void	EermSetSlew(Eerm *e, float slew){	int i;	MMemEntry;	MTraceCall("eerm:\tEermSetSlew..");	e->tmptoken->f->slew = slew;	e->protof->slew = slew;	for (i = 0; i < e->Nt; i++)	{		e->tokens[i]->f->slew = slew;	}	MMemExit;	MTraceCall("eerm:\tEermSetSlew finished.");}//---------------------- FeatureSetWeightsvoid	FeatureSetWeights(Feature *f, float *w, int n){	MMemEntry;	MTraceCall("eerm:\tFeatureSetWeights..");	MWeightIsValid(w, n);	MFeatureIsValid(f);	while (n--)	{		f->weights[n] = w[n];			}	MMemExit;	MTraceCall("eerm:\tFeatureSetWeights finished.");}//---------------------- TokenSetSimplexvoid	TokenSetSimplex(Token *t, Simplex *s, Eerm *e){	MTraceCall("eerm:\tTokenSetSimplex..");	MTokenIsValid(t);	MSimplexIsValid(s);	if (t->Nn != s->Nn) 	{		/* Todo : use this version later.		t->coord = (float *)resizemem(t->coord, 			t->Nn * sizeof(float), s->Nn * sizeof(float));		t->vcoord = (float *)resizemem(t->vcoord, 			t->Nn * sizeof(float), s->Nn * sizeof(float));		*/		// Todo : clean up these here dependencies.		t->Nn = s->Nn;		initvec(t->coord, 0.0, e->Nn);		initvec(t->coord, 1.0 / (float)s->Nn, s->Nn);		initvec(t->vcoord, 0.0, e->Nn);	}	t->s = s;	MTokenIsValid(t);	MTraceCall("eerm:\tTokenSetSimplex finished.");	return;}//---------------------- TokenSetSimplexWithCoordvoid	TokenSetSimplexWithCoord(Token *t, Simplex *s, Eerm *e, float *coord, float *vcoord, int Nn){	MTraceCall("eerm:\tTokenSetSimplex..");	MTokenIsValid(t);	MSimplexIsValid(s);		// not yet implemented.	return;}//---------------------- FeatureUpdatevoid 	FeatureUpdate(Feature *f, float *in, int Nf){	int i;	MMemEntry;		MTraceCall("eerm:\tFeatureUpdate..");	MFeatureIsValid(f);	MAssertVoid((in != NULL), "Null pointer received");	MAssertVoid(Nf == f->Nf, "Wrong feature size!");		for (i = 0; i < Nf; i++)	{		f->out[i] = f->out[i] * f->slew + (1.0 - f->slew) * in[i];		}		MFeatureIsValid(f);	MMemExit;	MTraceCall("eerm:\tFeatureUpdate finished.");}//---------------------- TokenSetCoordvoid TokenSetCoord(Token *t, float *coord, float *vcoord, int Nn){	MMemEntry;	MTraceCall("eerm:\tTokenSetCoord..");	MTokenIsValid(t);	MAssertVoid((coord != NULL), "null ptr received");	MAssertVoid(Nn == t->s->Nn, "wrong Nn");		copyvec(coord,t->coord,Nn);	if (vcoord != NULL)	{		copyvec(vcoord,t->vcoord,Nn);	}	MTokenIsValid(t);	MMemExit;	MTraceCall("eerm:\tTokenSetCoord finished.");}//---------------------- NodeSetMeanvoid	NodeSetMean(Node *n, float *mean, int Nf){	MMemEntry;	MTraceCall("eerm:\tNodeSetMean..");	MNodeIsValid(n);	MAssertVoid((mean != NULL), "null ptr received");	MAssertVoid(Nf == n->Nf, "wrong Nf");	copyvec(mean, n->mean, Nf);		MNodeIsValid(n);	MMemExit;	MTraceCall("eerm:\tNodeSetMean finished.");}//---------------------- NodeSetVarvoid	NodeSetVar(Node *n, float *var, int Nf){	MMemEntry;	MTraceCall("eerm:\tNodeSetVar..");	MNodeIsValid(n);	MAssertVoid((var != NULL), "null ptr received");	MAssertVoid(Nf == n->Nf, "wrong Nf");	copyvec(1.0 / var, n->ivar, Nf);		MNodeIsValid(n);	MMemExit;	MTraceCall("eerm:\tNodeSetVar finished.");}//---------------------- NodeSetPotentialvoid	NodeSetPotential(Node *n, float potential){	MMemEntry;	MTraceCall("eerm:\tNodeSetPotential..");	MNodeIsValid(n);	//MAssertVoid(potential > 0.0, "negative potential");		n->potential = potential;	MMemExit;	MTraceCall("eerm:\tNodeSetPotential finished.");}//---------------------- SimplexSetTransitionint SimplexSetTp(Simplex *s1, Simplex *s2, float tp){	MMemEntry;	MTraceCall("eerm:\tSimplexSetTransition..");	if (!SimplexNeighbor(s1,s2)) 	{		MTraceCall("eerm:\tSimplexSetTransition finished.");		return 0;	}		s1->tp[s2->index] = tp;		ForceConvex(s1->tp, s1->NsMax);	MMemExit;	MTraceCall("eerm:\tSimplexSetTransition finished.");	return 1;}//====================== Forces//---------------------- SpringForcefloat SpringForce(float Coupling, float Distance){	return -1.0 * Coupling * Distance;}//---------------------- GravityForcefloat GravityForce(float Coupling, float Mass1, float Mass2, float Distance){	return -1.0 * Coupling * (Mass1 * Mass2) / (Distance * Distance);}//---------------------- TokenSensorForceAccumvoid TokenSensorForceAccum(Token *t, float *F, int Nn, int sensorforce){		int i;	float E;	MMemEntry;	MTraceCall("eerm:\tTokenSensorForceAccum..");	MTokenIsValid(t);	MAssertVoid(Nn == t->Nn, "incompatible simplex size");	MAssertVoid(F != NULL, "invalid force ptr");	// Calc the force due to each node:	for (i = 0; i < t->Nn; i++)	{		// Calc the coupling of the feature to the node:		E = NodeSensorCoupling(t->s->nodes[i], t->f);		#ifdef MTraceForce			post("Node %d : E_sensor = %f", t->s->nodes[i]->index, E);			post("Node %d : SensorCoupling = %f",t->s->nodes[i]->index,exp(-1.0 * t->expscale * E)); 		#endif 				if (sensorforce == 0)		{			F[i] += SpringForce(exp(-1.0 * t->expscale * E), t->coord[i] - 1.0)				 - t->damping * t->vcoord[i];		#ifdef MTraceForce			post("Node %d : SpringForce = %f",				t->s->nodes[i]->index,				SpringForce(exp(-1.0 * t->expscale * E), t->coord[i] - 1.0)					- t->damping * t->vcoord[i]); 		#endif 		}		else		{			F[i] += 			GravityForce(				exp(-1.0 * t->expscale * E), 				t->mass,				t->s->nodes[i]->potential,	// Todo : incorporate this better -				MMax(t->coord[i] - 1.0, 0.0001)) 				- t->damping * t->vcoord[i];		#ifdef MTraceForce			post("Node %d : GravityForce = %f",				t->s->nodes[i]->index,				GravityForce(					exp(-1.0 * t->expscale * E), 					t->mass,					t->s->nodes[i]->potential,	// Todo : incorporate this better -					MMax(t->coord[i] - 1.0, 0.0001)) 					- t->damping * t->vcoord[i]);		#endif 		}		#ifdef MTraceForce	 			MTrace2("TokenSensorForceAccum:\tF[%d] = %f",i,F[i]);		#endif	}			MMemExit;	MTraceCall("eerm:\tTokenSensorForceAccum finished.");}//---------------------- TokenTokenForceAccum// Todo : the more efficient way to do this is to compute a matrix// of forces for the whole Eerm, which need only be computed above// the diagonal.  void TokenTokenForceAccum(Token *t1, Token *t2, float *F1, int Nn1)// Computes the force F1 on token t1 due to t2.{		int i,j;	MMemEntry;		MTraceCall("eerm:\tTokenTokenForceAccum..");	MTokenIsValid(t1);	MTokenIsValid(t2);	MAssertVoid(Nn1 == t1->Nn, "incompatible simplex size");	MAssertVoid(F1 != NULL, "invalid force ptr");		initvec(F1, 0.0, Nn1);		if (t1->s == t2->s)	// Compute the intra-simplex interaction	{		for (i = 0; i++; i < Nn1)		{			F1[i] += SpringForce(t1->tokencoupling,t1->coord[i] - t2->coord[i]); 		}	}	else	// Compute a non-intra-simplex interaction:	{				for (i = 0; i < t1->Nn; i++)		{			j = SimplexNodeFind(t2->s, t1->s->nodes[i]);			if (j != -1)			{				F1[i] += SpringForce(t1->tokencoupling, 					-1.0 * (t1->coord[i] + t2->coord[j]));			}		}	}		MMemExit;	MTraceCall("eerm:\tTokenTokenForceAccum finished.");}//---------------------- TokenForce// Compute the net force on a single token.void TokenForce(Token *t, Eerm *e, float *F, int Nn){	int i;	MMemEntry;	MTraceCall("eerm:\tTokenForce..");	MTokenIsValid(t);	MEermIsValid(e);	MAssertVoid(Nn == t->Nn, "incompatible nn");	MAssertVoid(F != NULL, "invalid force ptr");	initvec(F, 0.0, Nn);	// 1. Calculate the force due to other tokens:	if (t->tokencoupling != 0.0)	{		for (i = 0; i < e->Nt; i++)		{			if (i != t->index)			{				TokenTokenForceAccum(t,e->tokens[i], F, Nn);			}		}	}		// 2. Calculate the SensorForce:		if (!t->stulle)	{		TokenSensorForceAccum(t, F, Nn, e->sensorforce);	}	// This is necessary for non-central forces:	ProjectTangentToSimplex(F, Nn);	#ifdef MTraceForce		for (i = 0; i < Nn; i++)		{			post("Net force F[%d] = %f", i, F[i]);		}	#endif	MMemExit;	MTraceCall("eerm:\tTokenForce finished.");}//---------------------- NodeSensorCoupling// Computes a log likelihood of the feature given the node,// as the weighted-squared distance between feature and node data. float NodeSensorCoupling(Node *n, Feature *f){	int i;	float df;	float D = 0.0;	MTraceCall("eerm:\tNodeSensorCoupling..");	MNodeIsValid(n);	MFeatureIsValid(f);	MAssertFloat(n->Nf == f->Nf, "incompatible nf");		for (i = 0; i < f->Nf; i++)	{		df = (n->mean[i] - f->out[i]) * f->weights[i];		D += df * df * n->ivar[i];		#ifdef MTraceForce			post("node %d, m - f = %f - %f = %f", 				n->index, 				n->mean[i],				f->out[i],				n->mean[i] - f->out[i]);		#endif 	}	MTraceCall("eerm:\tNodeSensorCoupling finished.");	return D;}//---------------------- EermForceMeter// Output the coupling of f to each node in e.void	EermForceMeter(Eerm *e, Feature *f, float *forces, int Nn){	int i;	MMemEntry;			MTraceCall("eerm:\tEermForceMeter..");	MEermIsValid(e);	MFeatureIsValid(f);	MAssertVoid(Nn == e->Nn, "incompatible nn");	MAssertVoid(forces != NULL, "invalid force ptr");	MAssertVoid(f->Nf == e->protof->Nf, "incompatible nf");	for (i = 0; i < Nn; i++)	{		forces[i] = NodeSensorCoupling(e->nodes[i], f);	}		MMemExit;	MTraceCall("eerm:\tEermForceMeter finished.");}//====================== Evolution//---------------------- TokenEvolve// Evolve a single token of the eerm.void	TokenEvolve(Token *t, Eerm *e){	int i;	float *F;	float InverseMass;	MMemEntry;	MTraceCall("eerm:\tTokenEvolve..");	MEermIsValid(e);	MTokenIsValid(t);		MAssertVoid(e->dt >= KMinDt, "Invalid interval");	F = (float *)getmem(t->Nn * sizeof(float));	initvec(F, 0.0, t->Nn);	TokenForce(t,e,F,t->Nn);		InverseMass = 1.0 / t->mass;	for (i = 0; i < t->Nn; i++) 	{		t->coord[i]  += t->vcoord[i] * e->dt;		t->vcoord[i] += F[i] * InverseMass * e->dt;	}	// This should be necessary only due to roundoff errors:	ForceConvex(t->coord, t->Nn);	#ifdef MTraceEvolve	for (i = 0; i < t->Nn; i++)	{		MTrace4("TokenEvolve:\tInverseMass = %f, F[%d] = %f, dt = %f", InverseMass, i, F[i], e->dt);		MTrace2("TokenEvolve:\tdCoord[%d] = %f", i, t->vcoord[i] * e->dt);		MTrace2("TokenEvolve:\tdVcoord[%d] = %f", i, F[i] * InverseMass * e->dt); 		MTrace2("TokenEvolve:\tvcoord[%d] = %f", i, t->vcoord[i]);	}	#endif	freemem(F, t->Nn * sizeof(float));	TokenCheckTransition(t, e);		MTraceCall("eerm:\tTokenEvolve finished.");	MMemExit;}//---------------------- EermTokensEvolve// Evolve all tokens in the Eerm.void	EermTokensEvolve(Eerm *e){	int i = 0;	int j = 0;	MMemEntry;	MTraceCall("eerm:\tEermTokensEvolve..");	MEermIsValid(e);	while (i < e->Nt)	{		// Todo : find out if this is safe practice. For now, the token-delete function is MInvalid-ed.  		// Todo : implement the same idea elsewhere, as it looks like we are		// going with it.		MAssertVoid(!(!(e->tokens[j]) && (!(e->tokens[j] == NULL))), "Bad assumption");   		if (e->tokens[j])  // can this just be written "if (e->tokens[j])" ?		{			TokenEvolve(e->tokens[j], e);			i++;		}		j++;	}			MMemExit;	MTraceCall("eerm:\tEermTokensEvolve finished.");}//---------------------- ForceConvexvoid	ForceConvex(float *f, int n){	int i;	double s = 0.0;	MMemEntry;		for (i = 0; i < n; i++)	{		// zero any negative parts:		if (f[i] < 0.0) f[i] = 0.0;		// accumulate the sum:		s = s + f[i];	}	s = 1.0 / s;	// Normalize the sum	for (i = 0; i < n; i++)	{		f[i] = f[i] * s;	}	MVectorIsConvex(f,n);	MMemExit;}//---------------------- ProjectTangentToSimplexvoid	ProjectTangentToSimplex(float *f, int n){	int i;	double sum = 0.0;	MMemEntry;	MTraceCall("eerm:\tProjectTangentToSimplex..");	for (i = 0; i < n; i++)	{		sum = sum + (double)(f[i]);	}	sum = sum / (double)n;	for (i = 0; i < n; i++)	{		f[i] = f[i] - sum;	}		MVectorIsTangent(f,n);  // assert on non-tangent.	MMemExit;	MTraceCall("eerm:\tProjectTangentToSimplex finished.");}//====================== Token Transition//---------------------- TokenCheckTransition// Determine if a transition between simplices is warranted by the// dynamics, and if so, execute it.void TokenCheckTransition(Token *t, Eerm *e){		int n = t->Nn; 	int SimplexNodeLostIndex = -1;	MMemEntry;	MTraceCall("eerm:\tTokenCheckTransition..");	MTokenIsValid(t);	MWeightIsValid(t->coord, t->Nn);		// Determine if we have hit a boundary:	SimplexNodeLostIndex = TokenCheckBoundary(t);		if (SimplexNodeLostIndex != -1)	{					TokenDoTransition(t, e, SimplexNodeLostIndex);	}	// Todo : Please assert the return values etc on the Token transition functions.;		MMemExit;	MTraceCall("eerm:\tTokenCheckTransition finished.");}//---------------------- TokenDoTransition// Perform the transition deleting the node with index SimplexNodeLostIndex,// if one exists, otherwise bounce off that boundary.  // Note: 0 <= SimplexNodeLostIndex < t->Nnvoid TokenDoTransition(Token *t, Eerm *e, int SimplexNodeLostIndex){	int i;	int NewSimplexIndex;	float *oldcoord;	float *oldvcoord;	int *perm;	MMemEntry;	MTraceCall("eerm:\tTokenDoTransition..");	MTokenIsValid(t);	MEermIsValid(e);	MAssert((SimplexNodeLostIndex >= 0) && (SimplexNodeLostIndex < t->Nn), "Invalid index");	MTrace1("eerm:\tTokenDoTransition removing %d.", SimplexNodeLostIndex);	MTokenTraceCoord(t);	perm 			= (int *)getmem(t->Nn * sizeof(int));	oldcoord 	= (float *)getmem(t->Nn * sizeof(float));	oldvcoord = (float *)getmem(t->Nn * sizeof(float));	// Record the old coordinate & velocity (reflecting the bdy vel)	t->vcoord[SimplexNodeLostIndex] *= -1.0;	copyvec(t->coord, oldcoord, t->Nn);	copyvec(t->vcoord, oldvcoord, t->Nn);	// Find the simplex to which we transition, or else stay on original:	NewSimplexIndex = TokenFindTransition(t, e, SimplexNodeLostIndex);	MTrace2("TokenDoTransition:\tTransition from simplex %d -> %d", t->s->index, NewSimplexIndex);	// Perform the transition:	if (!(NewSimplexIndex == t->s->index)) 	{		// Get the permutation from old to new simplex 		//   (e.g. 1 3 5 -> 1 2 3 returns perm 0 2 -1)	 	SimplexComparePermute(e->simplices[NewSimplexIndex], t->s, perm, t->Nn);		// Iterate over indices of the new simplex:	 	for (i = 0; i < t->Nn; i++)	 	{			// Todo : this only works because same-dimension simplices.			MTrace2("Transition Permutation: %d -> %d", i, perm[i]);				// Todo : integrate this better with ComparePermute.			if (perm[i] == -1)			{				t->coord[i]  = oldcoord[SimplexNodeLostIndex];		 		t->vcoord[i] = oldvcoord[SimplexNodeLostIndex];				// Debug:				//MTrace3("i = %d: set c = %f, v = %f", i, t->coord[i], t->vcoord[i]); 			}			else			{				MAssert((perm[i] >= 0) && (perm[i] < t->Nn), "invalid node index");		 		MAssert(t->s->nodes[perm[i]] == e->simplices[NewSimplexIndex]->nodes[i], "bad sort returned.");				MAssert(perm[i] != SimplexNodeLostIndex, "invalid permutation.");				// Set coordinates on the new simplex:		 		t->coord[i]  = oldcoord[perm[i]];		 		t->vcoord[i] = oldvcoord[perm[i]];				// Debug:				//MTrace3("i = %d: set c = %f, v = %f", i, t->coord[i], t->vcoord[i]); 			}	 	}				MTokenTraceCoord(t);		MAssert(t->s != e->simplices[NewSimplexIndex], "Simplex should not be set yet.");		// Todo : figure out how to reduce this to a call to TokenSetSimplexWithCoord(..)		t->s = e->simplices[NewSimplexIndex];	}		// Deallocate:	freemem(perm, t->Nn * sizeof(int));	freemem(oldcoord, t->Nn * sizeof(float));	freemem(oldvcoord, t->Nn * sizeof(float));	MTraceCall("eerm:\tTokenDoTransition finished.");	MMemExit;}//---------------------- TokenTraceCoordvoid TokenTraceCoord(Token *t){	int i;	MTokenIsValid(t);		for (i = 0; i < t->Nn; i++)	{		MTrace4("t->coord[%d] = %f   t->vcoord[%d] = %f", i, t->coord[i], i, t->vcoord[i]);	}	}//---------------------- TokenFindTransition// Look for the best available transition, if// there is one; return -1 if none found.// Note: 0 <= SimplexNodeLostIndex < t->Nnint TokenFindTransition(Token *t, Eerm *e, int SimplexNodeLostIndex){	int i;	int Test1,Test2;	// default to the original simplex:	int NewSimplexIndex = t->s->index;	MMemEntry;	MTraceCall("eerm:\tTokenFindTransition..");	MEermIsValid(e);	MTokenIsValid(t);	MAssertInt((SimplexNodeLostIndex >= 0) & (SimplexNodeLostIndex < t->Nn), "bad SimplexNodeLostIndex");	// Examine all e->simplices[i]	for (i = 0; i < e->Ns; i++)	{		// If  (1) A connection exists from t->s to e->simplices[i]		// and (2) e->simplices[i] does not contain node t->s->nodes[SimplexNodeLostIndex]		Test1 = (t->s->tp[i] > 0.0);		Test2 = (SimplexNodeFind(e->simplices[i], t->s->nodes[SimplexNodeLostIndex]) == -1);		if ((t->s->tp[i] > 0.0) && 			( SimplexNodeFind(e->simplices[i], t->s->nodes[SimplexNodeLostIndex]) == -1)) 		{ 			// Transition is best so far in the following cases: 			if (NewSimplexIndex == t->s->index) NewSimplexIndex = i; 			MAssertInt((NewSimplexIndex >= 0) && (NewSimplexIndex < e->Ns),  				"TokenFindTransition:\tBad NewSimplexIndex"); 			 			if (t->s->tp[i] > t->s->tp[NewSimplexIndex]) NewSimplexIndex = i; 		}	}			MMemExit;	MTraceCall("eerm:\tTokenFindTransition finished.");	return NewSimplexIndex;	}//---------------------- TokenCheckBoundary// Find out if a transition should occur, and if so,// which node of the current simplex should disappear.int TokenCheckBoundary(Token *t){	int i;	int SimplexNodeLostIndex = -1;	MTraceCall("eerm:\tTokenCheckBoundary..");	MTokenIsValid(t);	for (i = 0; i < t->s->Nn; i++)	{		if (t->coord[i] <= 0.0)		{			MTraceCall("eerm:\tTokenCheckBoundary finished.");			return i;		}	}	MTraceCall("eerm:\tTokenCheckBoundary finished.");	return -1;}//====================== Comparison//---------------------- NodeListCompare// Compare a pair of lists of ptrs to Nodes.int NodeListCompare(Node **n1, int Nn1, Node **n2, int Nn2){	int i;	int comparison = 1;	MMemEntry;	MTraceCall("eerm:\tNodeListCompare..");	MNodeListIsValid(n1, Nn1);	MNodeListIsValid(n2, Nn2);	if (Nn1 != Nn2) 	{		MTraceCall("eerm:\tNodeListCompare finished.");		return 0;	}			for (i = 0; i < MMin(Nn1, Nn2); i++)	{		comparison = comparison && (n1[i] == n2[i]);	}	MMemExit;		MTraceCall("eerm:\tNodeListCompare finished.");	return comparison;}		// Todo : Make sure all "return"s accompanied by MMemExit.				//---------------------- SimplexCompareCountint SimplexCompareCount(Simplex *s1, Simplex *s2)// returns the number of matching nodes, or -1 if different sizes.  see also below.{	int *n1, *n2;	int i, count=0, inc=0;	MMemEntry;	MTraceCall("eerm:\tSimplexCompareCount..");	MSimplexIsValid(s1);	MSimplexIsValid(s2);	n1 = (int *)getmem(s1->Nn * sizeof(int));	n2 = (int *)getmem(s2->Nn * sizeof(int));		for (i = 0; i < s1->Nn; i++)	{		n1[i] = s1->nodes[i]->index;	}	for (i = 0; i < s2->Nn; i++)	{		n2[i] = s2->nodes[i]->index;	}		// can do SortedCompare on addresses, because underlying indices are sorted:	count = SortedCompareCount(n1, s1->Nn, n2, s2->Nn);		freemem(n1, s1->Nn * sizeof(int));	freemem(n2, s2->Nn * sizeof(int));		MMemExit;		MTraceCall("eerm:\tSimplexCompareCount finished.");	return count;	}//---------------------- SimplexComparePermuteint SimplexComparePermute(Simplex *s1, Simplex *s2, int *p, int np)// does the same as above, but returns the permutation connecting them.{	int *n1, *n2;	int i=0, count=0, inc=0;	MMemEntry;	MTraceCall("eerm:\tSimplexComparePermute..");	MSimplexIsValid(s1);	MSimplexIsValid(s2);	MAssertInt(np == s1->Nn, "incompatible perm size");	n1 = (int *)getmem(s1->Nn * sizeof(int));	n2 = (int *)getmem(s2->Nn * sizeof(int));		for (i = 0; i < s1->Nn; i++)	{		n1[i] = s1->nodes[i]->index;	}	for (i = 0; i < s2->Nn; i++)	{		n2[i] = s2->nodes[i]->index;	}		// This returns p(i1) = i2.	count = SortedComparePermute(n1, s1->Nn, n2, s2->Nn, p, np);	freemem(n1, s1->Nn * sizeof(int));	freemem(n2, s2->Nn * sizeof(int));		MMemExit;		MTraceCall("eerm:\tSimplexComparePermute finished.");	return count;	}//---------------------- SimplexNodeFindint SimplexNodeFind(Simplex *s, Node *n){	// Todo: use the fact that the Node indices are 	// sorted to perform e.g. a binary search.	int i;	MMemEntry;		MTraceCall("eerm:\tSimplexNodeFind..");	MSimplexIsValid(s);	MNodeIsValid(n);		for (i = 0; i < s->Nn; i++)	{		if (s->nodes[i] == n) 		{			MTraceCall("eerm:\tSimplexNodeFind finished.");			MMemExit;			return i;		}	}			MMemExit;	MTraceCall("eerm:\tSimplexNodeFind..");	return -1;}//---------------------- SimplexNeighbor// Todo:// Is there a reasonable constraint here?// But we might want to generalize this to: s1 and s2 must// each lie in star({s1\n1, s2\n2}).int SimplexNeighbor(Simplex *s1, Simplex *s2){	int i;	MMemEntry;	MTraceCall("eerm:\tSimplexNeighbor..");	MSimplexIsValid(s1);	MSimplexIsValid(s2);		i = ( SimplexCompareCount(s1, s2) == (MMax(s1->Nn, s2->Nn) - 1) );	MMemExit;	MTraceCall("eerm:\tSimplexNeighbor finished.");			return i;}//--------------------------------------------------------------------------------//------------------------------ OPTIONAL ----------------------------------------//--------------------------------------------------------------------------------//---------------------- EermNodeDeletevoid	EermNodeDelete(Eerm *e, int i){	int j;	MMemEntry;	MEermIsValid(e);	MNodeIsValid(e->nodes[i]);	NodeFree(e->nodes[i]);	// e->Nn = e->Nn - 1; 		// [Todo] : these are ORDERED so we cannot simply decrement the foregoing.	//   one solution would be to use a linked list.  another would be to reallocatte	//   the empty slot as needed.  	// Alternately, we could use the mechanism used above, for the	// tokens, but again have the problem that anyone relying on the	// "index" of a node will have to update that information.		// This seems to point to the idea that we should not be using the "index"!		// (However, it makes NodeList math simpler.)		for (j=0; j<e->Ns; j++)	{		e->nodes[j]->tp[i] = 0.0;	}	MInvalid("not yet implemented");	MMemExit;		return;}//---------------------- EermMoreSimplicesvoid 	EermMoreSimplices(Eerm *e, int NsMax){	MMemEntry;		MEermIsValid(e);	MAssertVoid(NsMax > 0, "Bad arg NsMax");	MMemExit;		MInvalid("not yet implemented");}//---------------------- EermMoreNodesvoid 	EermMoreNodes(Eerm *e, int NnMax){	MMemEntry;		MEermIsValid(e);	MAssertVoid(NnMax > 0, "Bad arg NnMax");	MMemExit;		MInvalid("not yet implemented");}//---------------------- TokenObsvoid	TokenObs(Token *t, float *obs, int Nf){	MMemEntry;	MTokenIsValid(t);	MAssertVoid(Nf != t->Nf, "incompatible nf");	MInvalid("not yet implemented");		initvec(obs, 0.0, Nf);	MMemExit;}//---------------------- TokenTrainSimplexvoid	TokenTrainSimplex(Token *t){	MMemEntry;	MTokenIsValid(t);	MInvalid("not yet implemented");	MMemExit;}//---------------------- NodeFuseint	NodeFuse(Node *n1, Node *n2, int opt){	MMemEntry;	MNodeIsValid(n1);	MNodeIsValid(n2);	MAssertInt(opt >= 0, "bad opt");	// 1. Redirect	// 2. Collapse EermNodeList	// 3. Search for degenerates.	return -1;	MInvalid("not yet implemented");	MMemExit;}//---------------------- SimplexSubdivideNode *SimplexSubdivide(Simplex *s, Eerm *e){	MSimplexIsValid(s);	MAssertPtr(e != NULL, "invalid eerm ptr");	return NULL;	/*	int i,j;	Node *n;	Node **nodelist;	Simplex *snew;		SimplexIsValid(s);			// 1. Create the necessary node	n = NodeNew(1, e->tmpnode->Nf, e->NnMax);	EermNodeAdd(e, n);	initvec(n->ivar,0.0, n->Nf);	// 2. Compute the new node data	for (i = 0; i < s->Nn; i++)	{		for (j = 0; j < n->Nf; j++)		{			n->mean[j] += s->nodes[i]->mean[j] / s->Nn;			n->ivar[j] += s->nodes[i]->ivar[j] / s->Nn;		// <-not quite right.		}		n->potential += s->nodes[i]->potential / s->Nn;	}				// 3. Create the new simplices		nodelist = (Node **)getmem(s->Nn * sizeof(Node *));	for (i = 0; i < s->Nn; i++)	{		copyvec(s->nodes, nodelist, s->Nn);		nodelist[i] = n;	}		EermSimplexAdd(e, s->Nn, nodelist);		EermSimplexAdd(e, snew);		// Would be good to combine last 2 into EermSimplexAddNew(..)					// 4. Copy Simplex Data From the original simplex		// 5. Delete The Original Simplex	MInvalid("Not done yet..");	return n; */}/*void SimplexTokenTrain(Simplex *s, Token *t, float a, float vf) {	int f, i, Nf = n->Nf; size = s->size;	double dist, L, w, P, N, sumw = 0.0, sumv=0.0, *dm, *dV;	float *mm, *ivm;	if (size != t->size) {		error("smpmodel:token and simplex sizes must be equal!");		return;	}	dm = (double *)getmem((Nf * sizeof(double)));	dV = (double *)getmem((Nf * sizeof(double)));	mm =  (float *)getmem((Nf * sizeof(float)));	vm = (float *)getmem((Nf * sizeof(float)));		twopiNf = 2 * PI * Nf;	recipdistdenom = 1.0 / (2.0 * Nf);	for(i=0; i<size; i++) {		dist = 0.0;		w = t->coord[i];		for(f=0; f<Nf; f++) {			vm[f] = 1.0 / s->nodes[i].ivar[f];			mm[f] = s->nodes[i].mean[f];			dm[f] = t->obs[f] - mm[f];			dm2 = dm[f] * dm[f];			dist = dist + dm2 * s->nodes[i].ivar[f];			dV[f] = dm2 - vm[f];		}		dist = dist * recipdistdenom;		P = exp(-1.0 * dist);		L = a * w * P;		for(f=0; f < Nf; f++) {			s->nodes[i].mean[f] + L * dm[f];			vm[f] = vm[f] + L * dV[f];			s->nodes[i].ivar = 1.0 / (MAX(vm[f], vf));		}	}	freemem(dm, (Nf * sizeof(double)));	freemem(dV, (Nf * sizeof(double)));	freemem(mm, (Nf * sizeof(float)));	freemem(vm, (Nf * sizeof(float)));}	*/