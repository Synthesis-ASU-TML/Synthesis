// eermDefines.h#ifndef _eermDefines_h#define _eermDefines_h//#include <stdlib.h>//#include <stdio.h>//#include "ext.h"//#define NDEBUG	 		// switches OFF assert() in assert.h//#undef NDEBUG//#include <assert.h>//====================== Debug Defines#define MDebug  		// switches on other eerm debug stuff//#define MemDebug	// switch for memory allocation debugging.  										// uses globals, so only one instance of eerm should be created if this is on.//#define MErrors 		// switches on errors (not recommended to turn off)#define MErrorsDebug	// switches on errors with DebugStr #define MAssertions 	// switches on eerm assertion macro (calling assert() and error()) #define MTraces 				// switches on eerm traces//#define MTraceEvolve	// switches on trace of deltas//#define MTraceForce		//#define MTraceCalls 	// switches on eerm traces of function calls//----------------------- Globalsstatic int iii;#ifdef MemDebug	long membytes=0;	long memeermmaxlabels=0;#endif//----------------------- Types#define TBool int//----------------------- Constants#ifndef RAND_MAX#define RAND_MAX 32767  // already defined in ANSI implementations#endif#define KEpsilon	0.000001  // huh?#define KPi				3.1415926535897932384626433832797#define KMinDt		1.0//----------------------- Numerical Macros#define MMax(a,b) 	(((a) > (b)) ? (a) : (b))#define MMin(a,b)    (((a) < (b)) ? (a) : (b))#define MAbs(a) 		(((a) < 0) ? (-a) : (a))#define MFloor(a,f)  	(((a) == 0.0) ? (f) : (a))//----------------------- Memory Macros#ifdef MemDebug	#define getmem(size) \		(((size)<32767)?getbytes(size):NewPtr(size)); \		membytes = membytes + size;	#define freemem(var,size) \		if ((size)<32767){freebytes((char *)(var),(short)(size));} \		else{DisposePtr((char *)var);} \			membytes = membytes - size;#else	#define getmem(size) \		(((size)<32767)?getbytes(size):NewPtr(size)); 	#define freemem(var,size) \		if ((size)<32767){freebytes((char *)(var),(short)(size));} \		else{DisposePtr((char *)var);} #endif#define initvec(vec,val,size) \	for (iii=0; iii<size; iii++) {vec[iii]=val;} #define copyvec(vec1,vec2,size) \	for (iii=0; iii<size; iii++) {vec2[iii] = vec1[iii];}		//======================== Debugging//----------------------- External definitionsvoid error(char *, ...);void post(char *, ...);//----------------------- Errors#ifdef MErrors		#define MError(expression, msg) {if (!(expression)) {error(msg);}}	#define MErrorVoid(expression,msg) {if (!(expression)) {error(msg); return;}}	#define MErrorPtr(expression,msg) {if (!(expression)) {error(msg); return NULL;}}	#define MErrorInt(expression,msg) {if (!(expression)) {error(msg); return -1;}}	#define MErrorFloat(expression,msg) {if (!(expression)) {error(msg); return -1.0;}}#else 	#ifdef MErrorsDebug			#define MError(expression, msg) {if (!(expression)) {error(msg);DebugStr((const unsigned char *)msg);}}		#define MErrorVoid(expression,msg) {if (!(expression)) {error(msg); DebugStr((const unsigned char *)msg);return;}}		#define MErrorPtr(expression,msg) {if (!(expression)) {error(msg); DebugStr((const unsigned char *)msg); return NULL;}}		#define MErrorInt(expression,msg) {if (!(expression)) {error(msg); DebugStr((const unsigned char *)msg); return -1;}}		#define MErrorFloat(expression,msg) {if (!(expression)) {error(msg); DebugStr((const unsigned char *)msg); return -1.0;}}	#else		#define MError(expression, msg) {}		#define MErrorVoid(expression,msg) {}		#define MErrorPtr(expression,msg) {}		#define MErrorInt(expression,msg) {}		#define MErrorFloat(expression,msg) {}	#endif#endif//----------------------- Assertions#ifdef MAssertions		#define MAssert(expression,msg) {assert(expression); if (!(expression)) {DebugStr((const unsigned char *)msg); error(msg);}}	#define MAssertVoid(expression,msg) {assert(expression); if (!(expression)) {DebugStr((const unsigned char *)msg); error(msg); return;}}	#define MAssertPtr(expression,msg) {assert(expression); if (!(expression)) {DebugStr((const unsigned char *)msg); error(msg); NULL;}}	#define MAssertInt(expression,msg) {assert(expression); if (!(expression)) {DebugStr((const unsigned char *)msg); error(msg); return -1;}}	#define MAssertFloat(expression,msg) {assert(expression); if (!(expression)) {DebugStr((const unsigned char *)msg); error(msg); return -1.0;}}	#define MInvalid(msg) {DebugStr((const unsigned char *)msg); error(msg);}#else	#define MAssert(expression, msg) {}	#define MAssertVoid(expression,msg) {}	#define MAssertPtr(expression,msg) {}	#define MAssertInt(expression,msg) {}	#define MAssertFloat(expression,msg) {}	#define MInvalid(msg) {}#endif#ifdef MemDebug	#define MMemEntry int memcount = membytes;	#define MMemExit {if (memcount != membytes) {error("eerm:\tmemory leak here."); post("eerm:\t%d -> %d bytes",memcount,membytes); DebugStr((const unsigned char *)("memory leak here"));}}	#define MPostMemChange {post("Mem usage changed %d bytes", (memcount - membytes));}	#define MMemChkStart int memcount = membytes;	#define MMemChkExit(gmem){gmem += membytes - memcount;}#else	#define MMemEntry	#define MMemExit	#define MPostMemChange 	#define MMemChkStart	#define MMemChkExit(gmem)#endif//----------------------- Traces#ifdef MTraces#define MTrace(msg) {post(msg);}#define MTrace1(msg,val1) {post(msg,val1);}#define MTrace2(msg,val1,val2) {post(msg,val1,val2);}#define MTrace3(msg,val1,val2,val3) {post(msg,val1,val2,val3);}#define MTrace4(msg,val1,val2,val3,val4) {post(msg,val1,val2,val3,val4);}#define MTrace5(msg,val1,val2,val3,val4,val5) {post(msg,val1,val2,val3,val4,val5);}#else#define MTrace(msg) {}#define MTrace1(msg,val1) {}#define MTrace2(msg,val1,val2) {}#define MTrace3(msg,val1,val2,val3) {}#define MTrace4(msg,val1,val2,val3,val4) {}#define MTrace5(msg,val1,val2,val3,val4,val5) {}#endif#ifdef MTraceCalls#define MTraceCall(msg) {post(msg);}#else#define MTraceCall(msg) {}#endif#define unused(var) {iii = (int)&var;}//========// Macros//========#ifdef MDebug#define MVectorIsPositive(w,n) VectorIsPositive(w,n)#define MWeightIsValid(w,n) WeightIsValid(w,n)#define MVectorIsTangent(w,n) VectorIsTangent(w,n)#define MVectorIsConvex(w,n) VectorIsConvex(w,n)#define MNodeIsValid(n) NodeIsValid(n)#define MNodeListIsValid(n,Nn) NodeListIsValid(n,Nn)#define MTokenIsValid(t) TokenIsValid(t)#define MSimplexIsValid(s) SimplexIsValid(s)#define MSimplexIsValidWithoutNodes(s) SimplexIsValidWithoutNodes(s)#define MFeatureIsValid(f) FeatureIsValid(f)#define MEermIsValid(e) EermIsValid(e)#define MTokenTraceCoord(t) TokenTraceCoord(t)#else#define MVectorIsPositive(w,n) #define MWeightIsValid(w,n) #define MVectorIsTangent(w,n) #define MNodeIsValid(n) #define MNodeListIsValid(n,Nn) #define MTokenIsValid(t) #define MSimplexIsValid(s) #define MSimplexIsValidWithoutNodes(s)#define MFeatureIsValid(f) #define MEermIsValid(e) #define MTokenTraceCoord(t)#endif//------------------- Atom Macros#define arg_num(val,idx,ac,av) \	if ((av)&&((ac)>(idx))) { \		if ((av)[(idx)].a_type==A_LONG) (val) = (av)[(idx)].a_w.w_long; \		else if ((av)[(idx)].a_type==A_FLOAT) (val) = (av)[(idx)].a_w.w_float; \	}#define MAtomToVec(ac, av, n) 			\	if (av[0].a_type == A_LONG) 			\	{ 												\		for (iii = 0; iii < ac; iii++) 	\			n[iii] = av[iii].a_w.w_long; 	\	} 												\	else if (av[0].a_type == A_FLOAT) 	\	{ 												\		for (iii = 0; iii < ac; iii++) 	\			n[iii] = av[iii].a_w.w_float; \	} 												\	else {error("invalid atom type");}			#define MAtomLongToVec(ac, av, n) \	for (iii = 0; iii < ac; iii++) \		n[iii] = av[iii].a_w.w_long;		//----------------------- More Traces#ifdef MTraces#define MTraceSimplices(m) TraceSimplices(m)#define MTraceLabels(m) TraceLabels(m)#else#define MTraceSimplices(m) {}#define MTraceLabels(m) {}#endif	//======================= Functions//----------------------- resizememvoid *resizemem(void *var, long oldsize, long newsize);//----------------------- resizememinline void *resizemem(void *var, long oldsize, long newsize){	MAssertPtr(var != NULL, "null ptr");	MAssertPtr((oldsize > 0) && (newsize > 0), "");	MTrace2("eerm:\resizemem %d -> %d",oldsize,newsize);		//--Deallocate:	if ((oldsize) < 32767) 										{ 																		freebytes((char *)(var),(short)(oldsize)); 		} 												else 											{ 													DisposePtr((char *)var); 			} 												#ifdef MemDebug		membytes = membytes - oldsize; 		#endif		//--Allocate:		#ifdef MemDebug		membytes = membytes + newsize;	#endif	if ((newsize)<32767) 					{ 													return getbytes(newsize);	} 												else 											{ 													return NewPtr(newsize); 		} 											}#endif