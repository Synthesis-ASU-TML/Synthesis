/*    receive an int between 0-255 over OSC and write it to the serial port    most of the code butchered from simeplesynth-osc.c   *//*Copyright © 1998. The Regents of the University of California (Regents). All Rights Reserved.Written by Matt Wright, The Center for New Music and Audio Technologies,University of California, Berkeley.Permission to use, copy, modify, distribute, and distribute modified versionsof this software and its documentation without fee and without a signedlicensing agreement, is hereby granted, provided that the above copyrightnotice, this paragraph and the following two paragraphs appear in all copies,modifications, and distributions.IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISINGOUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HASBEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO,THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULARPURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDEDHEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDEMAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.The OpenSound Control WWW page is     http://www.cnmat.berkeley.edu/OpenSoundControl*/#include <OSC-common.h>#include <OSC-timetag.h>#include <OSC-address-space.h>#include <OSC-receive.h>/* for select(2) */#include <unistd.h>#include <sys/types.h>#include <sys/time.h>#include <stdint.h>#include <math.h>#define PI 3.14159265358979323/* For UDP stuff */#include <stdio.h>#include <string.h>#include <stdlib.h>#include <fcntl.h>#include <sys/stat.h>#include <netinet/in.h>#include <rpc/rpc.h>#include <sys/socket.h>#include <sys/un.h>#include <sys/times.h>#include <sys/param.h>#include <sys/ioctl.h>#include <ctype.h>#include <arpa/inet.h>#include <netdb.h>#include <pwd.h>#include <signal.h>#include <grp.h>#include <sys/file.h>#include <sys/prctl.h>#include <termios.h>typedef int FileDescriptor;static FileDescriptor initudp(int port) {	struct sockaddr_in serv_addr;	int n, sockfd;		if((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)			return sockfd;	bzero((char *)&serv_addr, sizeof(serv_addr));	serv_addr.sin_family = AF_INET;	serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);	serv_addr.sin_port = htons(port);		if(bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0)	{		perror("unable to  bind\n");		return -1;	}	fcntl(sockfd, F_SETFL, FNDELAY); 	return sockfd;}static void closeudp(int sockfd) {    close(sockfd);}static int time_to_quit;static void catch_sigint()  {   time_to_quit = 1;}#include <NetworkUDP.h>void ReceivePacket(int sockfd) {    OSCPacketBuffer pb;    struct NetworkReturnAddressStruct *ra;    int maxclilen=sizeof(struct sockaddr_in);    int n;    int capacity = OSCGetReceiveBufferSize();    int morePackets = 1;    char *buf;    while(morePackets) {	pb = OSCAllocPacketBuffer();	if (!pb) {	    OSCWarning("Out of memory for packet buffers---had to drop a packet!");	    /* How do I actually gobble down the packet? */	    return;	}	buf = OSCPacketBufferGetBuffer(pb);	/* The type NetworkReturnAddressPtr is const in two ways, so that	   callback procedures that are passed the pointer can neither change	   the pointer itself or the data the pointer points to.  But here's	   where we fill in the return address, so we do a cast to a non-const	   type. */	ra = (struct NetworkReturnAddressStruct *) OSCPacketBufferGetClientAddr(pb);	ra->clilen = maxclilen;	ra->sockfd = sockfd;/*	printf("* recvfrom(sockfd %d, buf %p, capacity %d)\n", sockfd, buf, capacity); */	n = recvfrom(sockfd, buf, capacity, 0, &(ra->cl_addr), &(ra->clilen));	if (n > 0) {	    int *sizep = OSCPacketBufferGetSize(pb);	    *sizep = n;	    OSCAcceptPacket(pb);	    if (time_to_quit) return;	} else {	    OSCFreePacket(pb);	    morePackets = 0;	}    }}#define VSIZE 32 /* vector size */#define BIGGER_OF(a,b) ((a)>(b)?(a):(b))void MainLoop(FileDescriptor sockfd, FileDescriptor serialfd) {    fd_set read_fds;    /* largest file descriptor to search for */        int	nfds = sockfd + 1;    printf("MainLoop: sockfd %d\n", sockfd);    time_to_quit = 0;    sigset(SIGINT, catch_sigint);       /* set sig handler       */    while(!time_to_quit) {	/* Figure out the time tag corresponding to the time in the future that we haven't	   computed any samples for yet. */            	OSCInvokeAllMessagesThatAreReady(OSCTT_CurrentTime());	/* set up select */	FD_ZERO(&read_fds);	/* clear read_fds */	FD_SET(sockfd, &read_fds); 	/* give control back to OS scheduler to put us to sleep until the DAC	   queue drains and/or a character is available from standard input */	if (select(nfds, &read_fds, (fd_set *)0, (fd_set * )0, (struct timeval *)0) < 0) {	    /* select reported an error */	    perror("bad select"); 	    goto quit;	}	if(FD_ISSET(sockfd, &read_fds)) {#if DEBUG	        printf("receive\n");#endif	    ReceivePacket(sockfd);	}	while (OSCBeProductiveWhileWaiting()) {	}    }quit:    closeudp(sockfd);}/* OSC stuff */void *MyInitTimeMalloc(int numBytes) {    void *result = malloc(numBytes);/*    printf("** MyInitTimeMalloc(%6x bytes): %p -> %p\n", numBytes, result, ((char *)result)+numBytes); */    return result;}void *MyRealTimeMalloc(int numBytes) {    return 0;}void SerialMethod(void *context, int arglen, const void *vargs, OSCTimeTag when, NetworkReturnAddressPtr ra) {  const char *cargs = (char*)vargs;  const uint32_t *iargs;  FileDescriptor serialfd;  int i,res;  uint8_t byte_buf;#if DEBUG  printf("getting serial\n");#endif  serialfd = (FileDescriptor*)context;#if DEBUG  printf("serialfd: %d\n",serialfd);#endif#if DEBUG  printf("arglen %d\n",arglen);  for(i=0;i<arglen;i++) {    printf("[%hhx] ",*(uint8_t*)(vargs+i));  }  printf("\n");#endif  if(cargs[0]==',') {#if DEBUG    printf("typetag?\n");#endif    if(cargs[1]=='i') {#if DEBUG      printf("int typed arg\n");#endif      /* skip past alignment */      iargs = (uint32_t*)(cargs+4);    } else {#if DEBUG      printf("wrong type\n");#endif      return;    }  } else {#if DEBUG    printf("untyped\n");#endif    iargs = (uint32_t*)cargs;  }  byte_buf = ntohl(*iargs);#if DEBUG  printf("arg[%d]\n",byte_buf);#endif  res = write(serialfd,&byte_buf,1);  /* res = dprintf(serialfd,"0x%x \n",byte_buf); */#if DEBUG  printf("dprintf returned %d\n",res);#endif  /*tcflush(serialfd,TCOFLUSH);*/}void InitOSCAddrSpace(FileDescriptor serialfd) {    Boolean result;    OSCcontainer OSCTopLevelContainer, tx;    struct OSCAddressSpaceMemoryTuner t;    struct OSCContainerQueryResponseInfoStruct cqinfo;    struct OSCMethodQueryResponseInfoStruct QueryResponseInfo;    /* Address space */    t.initNumContainers = 20;    t.initNumMethods = 20;    t.InitTimeMemoryAllocator = MyInitTimeMalloc;    t.RealTimeMemoryAllocator = MyRealTimeMalloc;    /* InitOSCAddrSpace and OSCInitAddressSpace? thats fugly */    OSCTopLevelContainer = OSCInitAddressSpace(&t);    OSCInitContainerQueryResponseInfo(&cqinfo);    tx = OSCNewContainer("tx", OSCTopLevelContainer, &cqinfo);       OSCInitMethodQueryResponseInfo(&QueryResponseInfo);    OSCNewMethod("d1", tx, SerialMethod, (void*)serialfd, &QueryResponseInfo);}void InitOSCReceive() {    struct OSCReceiveMemoryTuner rt;    Boolean result;    rt.InitTimeMemoryAllocator = MyInitTimeMalloc;    rt.RealTimeMemoryAllocator = MyRealTimeMalloc;    rt.receiveBufferSize = 1000;    rt.numReceiveBuffers = 100;    rt.numQueuedObjects = 200;    rt.numCallbackListNodes = 100;    result = OSCInitReceive(&rt);    if (result == FALSE) {	fatal_error("OSCInitReceive returned FALSE!\n");    }}void InitOSC(FileDescriptor serialfd) {    InitOSCAddrSpace(serialfd);    InitOSCReceive();}int main() {       FileDescriptor sockfd,serialfd;	    int udp_port = 5333;    char *modem_device = "/dev/ttySA0";    struct termios oldtio, newtio;                                               /* char buf[255]; */                     serialfd = open(modem_device, O_RDWR );                                 if (serialfd <0) {      perror(modem_device);       exit(-1);    }                                #if 1                                                                                tcgetattr(serialfd,&oldtio); /* save current port settings */                         bzero(&newtio, sizeof(newtio));                                             cfmakeraw(&newtio);        cfsetospeed(&newtio,B9600);    /* newtio |= PARENB; */    tcsetattr(serialfd,TCSAFLUSH,&newtio);    #endif        sockfd = initudp(udp_port);    if(sockfd<0) {	perror("initudp");	return;    }    InitOSC(serialfd);    MainLoop(sockfd,serialfd);#if 1    tcsetattr(serialfd,TCSANOW,&oldtio);          #endif    return;}