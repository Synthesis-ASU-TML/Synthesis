/*   adxl.c  this is the "time machine" version of the adxl driver.  by "time machine", i mean that performing a read gives you the most recently read value (or blocks if there isn't one), instead of giving you the next read value (as was the case with the last version).  licencing    copyright 2002, FoAM vzw, Belgium and Steven Pickles.     may be modified and distributed under the terms of the GNU general public licence (GPL).     see LICENCE file for details.*/#ifndef __KERNEL__#  define __KERNEL__#endif#ifndef MODULE#  define MODULE#endif#include <linux/config.h>#include <linux/module.h>#include <linux/sched.h>#include <linux/kernel.h> /* printk() */#include <linux/fs.h>     /* everything... */#include <linux/errno.h>  /* error codes */#include <linux/delay.h>  /* udelay */#include <linux/mm.h>#include <linux/ioport.h>#include <linux/interrupt.h>#include <linux/tqueue.h>#include <linux/init.h>#include <asm/system.h>#include <asm/uaccess.h>#include <asm/io.h>#include <asm/irq.h>#if 0#  define PDEBUG(fmt, args...) printk( KERN_DEBUG "adxl: " fmt, ## args)#else#  define PDEBUG(fmt, args...) /* not debugging: nothing */#endif#ifndef SA1100_GPIO_TO_IRQ#  define SA1100_GPIO_TO_IRQ(i)	(((i)<11) ? (i) : GPIO_11_27_IRQ(i))#endifunsigned int adxl_major = 240;MODULE_PARM(adxl_major,"i");MODULE_PARM_DESC(adxl_major,"the major device number to use. defaults to 240 (which is reserved for local use)");unsigned int adxl_timeout = 0;MODULE_PARM(adxl_timeout,"i");MODULE_PARM_DESC(adxl_timeout,"the number of milliseconds before timing out. defaults to 0 (non-blocking).");int adxl_errno = EWOULDBLOCK;MODULE_PARM(adxl_errno,"i");MODULE_PARM_DESC(adxl_errno,"the error code to return when timing out. defaults to EWOULDBLOCK (11).");/* we will just have one queue for all of the possible devices at first.    it should not cause too much overhead, but if it does, look in to how to declare wait queues dynamically per device */DECLARE_WAIT_QUEUE_HEAD(adxl_queue);#define STATE_WAIT_START      0#define STATE_WAIT_LOW        1#define STATE_WAIT_END        2#define STATE_NO_DATA         0#define STATE_HAS_DATA        1struct adxl_device {  int wait_state;  int data_state;  int gpio_line;   u32 duty_start_time;  u32 duty_low_time;  u32 duty_end_time;  u32 working_start_time;  u32 working_low_time;  spinlock_t duty_lock;};void adxl_interrupt(int irq, void *dev_id, struct pt_regs *regs) {  u32 current_time = OSCR;  u32 gpio_state = GPLR;  struct adxl_device *device = dev_id;  /* printk("adxl_interrupt\n"); */    if (gpio_state & GPIO_GPIO(device->gpio_line)) {    if (device->wait_state==STATE_WAIT_LOW) {           device->working_low_time = current_time;      device->wait_state = STATE_WAIT_END;            return;    }  /* here we know that the line is low, check if thats what we want */  } else {    if (device->wait_state==STATE_WAIT_START) {      device->working_start_time = current_time;      device->wait_state = STATE_WAIT_LOW;      return;    }     else if (device->wait_state==STATE_WAIT_END) {      PDEBUG("adxl_interrupt:try lock\n");      if(spin_trylock(&(device->duty_lock))) {	PDEBUG("adxl_interrupt:got lock\n");	device->duty_start_time = device->working_start_time;	device->duty_low_time = device->working_low_time;	device->duty_end_time = current_time;	device->data_state = STATE_HAS_DATA;	spin_unlock(&(device->duty_lock));	/* wake up any readers */	wake_up_interruptible(&adxl_queue);      }      device->working_start_time = current_time;      device->wait_state = STATE_WAIT_LOW;            return;    }  }  /* turning this bit of code on seems to kill the driver for some reason */#if 0  printk(KERN_DEBUG "unhandled adxl interrupt (device->wait_state %d, gpio_state %d)\n",device->wait_state,(gpio_state & GPIO_GPIO(device->gpio_line)?1:0));#endif}int adxl_open (struct inode *inode, struct file *filp) {  struct adxl_device *device;  MOD_INC_USE_COUNT;  PDEBUG("adxl_open()\n");  /* allocate and set up the device structure */  device = (struct adxl_device*)kmalloc(sizeof(struct adxl_device), GFP_KERNEL);  spin_lock_init(&(device->duty_lock));  PDEBUG("adxl_open:set state\n");  device->wait_state = STATE_WAIT_START;  device->data_state = STATE_NO_DATA;  PDEBUG("adxl_open:set gpio\n");  device->gpio_line = MINOR(inode->i_rdev);    PDEBUG("adxl_open:store it in flip\n");  /* store it in the file object so that read knows what we are talking about */  filp->private_data = device;    PDEBUG("adxl_open:set dir\n");  /* make sure the line is an input */  GPDR &= ~GPIO_GPIO(device->gpio_line);  PDEBUG("adxl_open:set edges\n");  /* listen for both edges */  set_GPIO_IRQ_edge(GPIO_GPIO(device->gpio_line), GPIO_BOTH_EDGES);#if 1  PDEBUG("adxl_open:request irq\n");  /* request the irq and also send the device structure */  if (request_irq (SA1100_GPIO_TO_IRQ(device->gpio_line), adxl_interrupt, SA_INTERRUPT, "ADXL", device) != 0) {    /*if (request_irq (SA1100_GPIO_TO_IRQ(device->gpio_line), adxl_interrupt, 0, "ADXL", device) != 0) {*/    printk(KERN_INFO "adxl_open:couldn't get IRQ\n");    return -EBUSY;  }#endif#if 0  PDEBUG("adxl_open:disable irq\n");  /* immediately disable it, we will re-enable it at read */  disable_irq(SA1100_GPIO_TO_IRQ(device->gpio_line));#endif  return 0;}ssize_t adxl_read(struct file *filp, char *buf, size_t count, loff_t *f_pos) {  int timed_out = 0;  struct adxl_device *device = filp->private_data;  u16 ratio;  /* unsigned long flags; */  u32 high_period;  u32 total_period;  PDEBUG("adxl_read()\n");  if (count<sizeof(u16)) {    /* read too small */    return -EIO;  }  PDEBUG("adxl_read:wait for data\n");  /* a little optimisation for the case of immediate timeout (non blocking) */  if (adxl_timeout==0) {    timed_out = device->data_state!=STATE_HAS_DATA;  } else {    while (!timed_out && device->data_state!=STATE_HAS_DATA) {      /* waits max 1 second which is very long */      timed_out = interruptible_sleep_on_timeout(&adxl_queue,adxl_timeout*HZ/1000) == 0;    }  }  if (timed_out) {    printk(KERN_INFO "adxl_read: read timed out\n");    return -adxl_errno;  }  PDEBUG("adxl_read:do math\n");  /* lets assume we have data here */  spin_lock(&(device->duty_lock));  high_period = device->duty_low_time - device->duty_start_time;  total_period = device->duty_end_time - device->duty_start_time;  /* so we don't read the same data twice */  device->data_state = STATE_NO_DATA;  spin_unlock(&(device->duty_lock));  ratio = (u64)65535*high_period/total_period;  PDEBUG("high_period %lu\n",high_period);  PDEBUG("total_period %lu\n",total_period);  PDEBUG("ratio %lu\n",ratio);#if 1  PDEBUG("adxl_read:copy to user space\n");  if (copy_to_user(buf,&ratio,sizeof(ratio))) {    return -EFAULT;  }#endif  return sizeof(ratio);  }int adxl_release (struct inode *inode, struct file *filp){  struct adxl_device *device = filp->private_data;  PDEBUG("adxl_release()\n");#if 1  PDEBUG("adxl_read:free irq\n");    free_irq(SA1100_GPIO_TO_IRQ(device->gpio_line),device);#endif  PDEBUG("adxl_read:free data\n");  kfree(filp->private_data);    MOD_DEC_USE_COUNT;  return 0;}/* NOTES:   - interruptible_sleep_on_timeout returns 0 if the timeout what reached (according to examples in the kernel)*/   struct file_operations adxl_fops = {  read: adxl_read,  open: adxl_open,  release: adxl_release,};int adxl_init(void)  {   int result;  PDEBUG("adxl_init()\n");  SET_MODULE_OWNER(&adxl_fops);  result = register_chrdev(adxl_major, "adxl", &adxl_fops);  if (result<0) {    printk(KERN_INFO "adxl: can't get major number %d\n",adxl_major);    return result;  }  return 0; }void adxl_exit(void) {   PDEBUG("adxl_exit()\n");  PDEBUG("adxl_exit:freeing chrdev\n");  unregister_chrdev(adxl_major, "adxl");}module_init(adxl_init);module_exit(adxl_exit);EXPORT_NO_SYMBOLS;