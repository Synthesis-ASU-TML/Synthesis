/*operate.creads acceleromeer data from GPIO pins on the cerfBoard and emits OSC packets. currently, it needs a host running Oz (or listening on a udp port) to aim the OSC stuff atuses a config file with lines in the format...    /dev/devname  /OSC/path/name/thing  min maxbasic structure:  - reads the config file  - constructs an array of ChannelConf with parameters, file handles for devices, etc  - loops through all getting data, then spits out all using OSCextensions for the footoor  - should be able to calibrate the sensors and write to conf file (see calibrate.c)  - the whole question of how to deal with floatsTo Compile and use:  - needs an arm cross compiler, the Makefile uses the one on nik's laptop  - then move the binary to the cerfboard with        scp operate root@62.116.80.132:.    - run it happily        operate -h <hostname/ip>// based upon the old operate.c cobbled together for t-garden.restructured 28 sept 2002 for the cerfboard - tmcopyright remains with the authors, and FoAM vzw, Belgium. may be modified and distributed under the terms of the GPL licence. see LICENCE file for details.version history0.0 tm: tim@timesup.org - reads from gpio0.1 nk: nik@f0.am - reduced udp overhead*/#include <stdio.h>#include <unistd.h>		/* getopt() */#include <string.h>#include <fcntl.h>#include <sys/types.h>#include <sys/socket.h>#include <netinet/in.h>#include <arpa/inet.h>#include <netdb.h>#include <sched.h>#include <time.h>#include <stdint.h>		/* uint8_t */#include "OSC-client.h"		/* OpenSoundControl *//* port to send TO */#define REMOTE_SERVER_PORT 5333#define OSC_BYTES 666#define NUM_CHAN 16/* max length of OSC route */#define OSC_ROUTE_MAX 80#define OSC_ROUTE_FILE "operate.conf"char *in_file_name;char *osc_host;FILE *route_file;int quiet;int send_float;char *progname;typedef struct{  int used;  char devname[20];  FILE *file;  int min;  int max;  int offset;  char route[OSC_ROUTE_MAX];  /* communicating with kernel space, so we should be unambiguous */  uint16_t data;  int amin;  int fullrange;  int last_sent_value;  int has_data;}ChannelConf;ChannelConf route[NUM_CHAN];void usage (){  printf ("Usage:\n");  printf ("%s -h host [-i in_file_name] [-s delay] [-q] [-f]\n", progname);  printf ("where\n");  printf ("host         : OSC server name or IP address\n");  printf ("in_file_name : input file (default /dev/ttySA0)\n");  printf ("sleep        : microseconds to sleep between reporting all sensors (default 0)\n");  printf ("-v = be verbose\n");  printf ("-f = send floats (default is to sent ints)\n");  printf ("-e = epsilon (changed data threshhold)\n");}void clean_exit (int state){  /* close what is open */  if (state > 3 || state == 0) {  }  if (state == 5) {    fclose (route_file);  }  exit (state);}int SendOSC (int sock, OSCbuf * b){  static int sd = -1;  int rc;  /* send data */  rc = send (sock, OSC_getPacket (b), OSC_packetSize (b), 0);	      if (rc < 0) {    printf ("cannot send data: %d \n", sock);    close (sock);    exit (1);  }  return 1;}int SetupOSC (char *host){  static int sd = -1;  int rc;  static struct sockaddr_in remoteServAddr;  struct hostent *h;  if (sd < 0 ) {    /* get server IP address (no check if input is IP address or DNS name */    h = gethostbyname (host);    if (h == NULL) {      printf ("unknown host '%s' \n", host);      exit (1);    }    remoteServAddr.sin_family = h->h_addrtype;    memcpy ((char *) &remoteServAddr.sin_addr.s_addr,	    h->h_addr_list[0], h->h_length);    remoteServAddr.sin_port = htons (REMOTE_SERVER_PORT);    /* socket creation */    sd = socket (AF_INET, SOCK_DGRAM, 0);    if (sd < 0) {      printf ("cannot open socket \n");      exit (1);    }    /* establish a connection to host (should really check for ICMP errors)*/    rc = connect (sd, (struct sockaddr *) &remoteServAddr,		  sizeof (remoteServAddr));    if (rc < 0) {      printf ("cannot bind port\n");      exit (1);    }  }  return sd;}int main (int argc, char *argv[]){  char *optstring;  static int osc_socket;  int option;  int tmp;  int i;  char *inp_buf;  FILE *calibfile;  char devicepath[50];  long next_read;  int epsilon;  long sleep;  /* struct timespec sleep_timespec; */  char *osc_route_file;  next_read = 0;  osc_host = NULL;  quiet = 1;  send_float = 0;  /*    sleep_timespec.tv_sec = 0;    sleep_timespec.tv_nsec = 0;  */  sleep = 0;  epsilon = 0;  osc_route_file = OSC_ROUTE_FILE;  progname = argv[0];  optstring = "i:h:s:vfe:c:";  while ((option = getopt (argc, argv, optstring)) != -1) {    switch (option) {    case 'i':      in_file_name = optarg;      break;    case 'h':      osc_host = optarg;      break;    case 'v':      quiet = 0;      break;    case 'f':      send_float = 1;      break;    case 's':      /*sleep_timespec.tv_nsec = atol(optarg);*/      sleep = atol(optarg);      break;    case 'e':      epsilon = atol(optarg);      break;    case 'c':      osc_route_file = optarg;      break;    }  }  if (osc_host == NULL) {    usage ();    clean_exit (-1);  }  if (!quiet) {    printf("running usleep(%ld) after each group of sensor values\n",sleep);    /* printf("running nanosleep(%ld) after each group of sensor values\n",sleep_timespec.tv_nsec); */    printf("using %ld as data-change threshold\n",epsilon);  }  /* open routing table */  printf("Opening routing table\n");  calibfile = fopen (osc_route_file, "r");  if (!calibfile) {    printf ("Can't open routing calibration table file %s\n", OSC_ROUTE_FILE);    clean_exit (4);  }  /* read calibration files/routing table */  for (i = 0; (i < NUM_CHAN) && (!feof(calibfile)); i++) {    int numread;    /* read "devname OSCname" pair, open /dev/devname, open cal.devname, store OSCname */    numread = fscanf(calibfile,"%s %s %d %d %d",		     &(route[i].devname),		     &(route[i].route),		     &(route[i].min),		     &(route[i].max),		     &(route[i].offset)		     );    if (numread == 5)      {	route[i].used = 1;	route[i].data = 0;	printf("read devname %s OSCname %s\n", route[i].devname, route[i].route);	/* these are made up */	route[i].amin      = route[i].min;	route[i].fullrange = route[i].max - route[i].min;	route[i].file = fopen(route[i].devname,"r");	route[i].last_sent_value = -1;	if (route[i].file == NULL)	  {	    printf("Device %s could not be opened.\n");	    i--;	  }      }  }  if (i < NUM_CHAN) route[i].used=0;  /* mark the first non-filled data struct */  fclose (calibfile);  /* open port for sending OSC */  osc_socket = SetupOSC (osc_host);  //SetupOSC(osc_host);  if (osc_socket == -1)   {    printf("Could not establish a connection to %s.\n",osc_host);   }  /* main loop */  while(1)    {      OSCbuf oscbuf;      char oscbytes[OSC_BYTES];      int ival;      float fval;      int osc_result;      OSC_initBuffer (&oscbuf, OSC_BYTES, oscbytes);             /* read the input */      for (i = 0; ((i < NUM_CHAN) && (route[i].used)); i++) {	if(fread(&(route[i].data),2,1,route[i].file)) {	  route[i].has_data=1;	} else {	  route[i].has_data=0;	}      }      /* decode the input */      for (i = 0; (i < NUM_CHAN) && (route[i].used); i++) {	if (!route[i].has_data) {	  if (!quiet) {	    printf("recieved no data from %s\n",route[i].devname);	  }	  continue;	}	ival = route[i].data + route[i].offset;		/* clip */	if (ival>65535) {	  ival = 65535;	}	if (ival<0) {	  ival = 0;	}		if (route[i].last_sent_value>=0 && abs(ival-route[i].last_sent_value)<epsilon) {	  if (!quiet) {	    printf("dropping packet %d\n",ival);	  }	  continue;	}	/* according to the datasheet, the offset should be sufficient for calibration */	if (send_float) {	  fval = ival / 65535.0f;	}			/* send */	if (!quiet) {	  	  if (send_float) {	    printf ("Channel %d, value %d, recalc value %5.3f, sent to %s\n", 		    i, route[i].data, fval, route[i].route);	  } else {	    printf ("Channel %d, value %d, sent to %s\n", 		    i, route[i].data, route[i].route);	  }	  	}	if (OSC_writeAddress(&oscbuf, route[i].route)) {	  printf ("OSC ERROR: %s\n",OSC_errorMessage);	}		/*  if (OSC_writeIntArg (&oscbuf, route[i].data)) { */	/*     printf ("OSC ERROR: %s\n", */	/* 	       OSC_errorMessage); */	/*  } */				if (send_float) {	  osc_result = OSC_writeFloatArg (&oscbuf, fval);	} else {	  osc_result = OSC_writeIntArg (&oscbuf, ival);	}		if (osc_result) {	  printf ("OSC ERROR: %s\n",OSC_errorMessage);	} else {	  route[i].last_sent_value = ival;	}		SendOSC (osc_socket, &oscbuf);		OSC_resetBuffer (&oscbuf);      }      /* should check that we sent something, and actually do a more intelligent check of time passed etc */      /*sched_yield();*/      /*nanosleep(&sleep_timespec,NULL);*/      usleep(sleep);    }  clean_exit (0);}